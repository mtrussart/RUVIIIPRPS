---
title: "Fast and accurate integration of TCGA BRCA RNA-seq data using the RUVIIIPRPS R package"
author:
- name: Ramyar Molania & Sepideh Foroutan
  affiliation: Papenfuss Lab, Bioinformatics, WEHI.
  url: https://www.wehi.edu.au/people/tony-papenfuss
date: "15-02-2020"
output:
  rmdformats::readthedown:
    code_folding: hide
    gallery: yes
    highlight: tango
    lightbox: yes
    self_contained: no
    thumbnails: no
    number_sections: yes
    toc_depth: 3
    use_bookdown: yes
  html_document2:
    df_print: paged
  html_document:
    toc_depth: '3'
    df_print: paged
params:
  update_date: !r paste("Last updated on:", Sys.Date())
editor_options:
  chunk_output_type: console
---
`r params$update_date`

<style type="text/css">
h1.title {
  font-size: 28px;
  color: DarkRed;
}
h1 { /* Header 1 */
  font-size: 24px;
  color: DarkBlue;
}
h2 { /* Header 2 */
    font-size: 20px;
  color: DarkBlue;
}
h3 { /* Header 3 */
    font-size: 18px;
  color: DarkBlue;
}
h4 { /* Header 3 */
    font-size: 16px;
  color: DarkBlue;
}
</style>

<style>
p.caption {
  font-size: 46em;
  font-style: italic;
  color: black;
}
</style>

```{r knitr_init, echo=FALSE, results="asis"}
library(knitr)
library(rmdformats)
library(DT)
library(BiocStyle)
```

```{r setup, include=F}
knitr::opts_chunk$set(
  tidy = FALSE,
  fig.width = 10,
  message = FALSE,
  warning = FALSE
)
```

# Introduction
In this vignette, we showed how to use the RUVIIIPRPS R package to normalize the TCGA breast cancer RNA-seq data.
First, we install RUVIIIPRPS package. You may need to install several dependencies first (see commented codes below) to be able to install the RUVIIIPRPS package. In this section, we also load required libraries and set the required paths.
## Install packages and set paths
```{r}
library(devtools)
library(SummarizedExperiment)

devtools::install_github(
    # repo = 'RMolania/RUVIIIPRPS@Ramyar-M',
    repo = 'RMolania/RUVIIIPRPS',
    force = TRUE,
    build_vignettes = FALSE)
# ERROR: dependencies ‘ggforestplot’, ‘qvalue’, ‘BiocSingular’, ‘BiocNeighbors’, ‘EDASeq’, ‘DESeq2’, ‘biomaRt’ are not available for package ‘RUVIIIPRPS’

# BiocManager::install(c(
#   'ggforestplot',
#   'qvalue',
#   'BiocSingular',
# # 'singscore',
# # 'kunstomverse',
# # 'SummarizedExperiment',
#   'BiocNeighbors',
#   'EDASeq',
#   'DESeq2',
#   'biomaRt'
# ))
## need to install two packages from Github: 
# devtools::install_github("NightingaleHealth/ggforestplot")
# devtools::install_github("jbkunst/kunstomverse")

library(RUVIIIPRPS)

# Error: package or namespace load failed for ‘RUVIIIPRPS’ in loadNamespace(j <- i[[1L]], c(lib.loc, .libPaths()), versionCheck = vI[[j]]):
#  namespace ‘tidyselect’ 1.2.0 is already loaded, but >= 1.2.1 is required

## change these paths according to your computer path:
dataPath <- "/Users/sep/Documents/data/RUVIIIPRPS_manual_data/"
figPath <- "/Users/sep/Documents/projects//RUVIIIPRPS/figures/"
```

 
# Download the data using the TCGAbiolinks R package

# Download, read and prepare the data
## TCGA-BRCA data
The TCGA Breast cancer data can be downloaded from the `TCGAbiolinks` package. The commented code below needs to be run only once to download the data, and for later use we can load the downloaded data.

```{r downloadingTheData, message=F, warning=F}
# harmonized.data <- TCGAbiolinks::GDCquery(
#     project = 'TCGA-BRCA',
#     data.category = 'Transcriptome Profiling',
#     data.type = 'Gene Expression Quantification'
#     )
# --------------------------------------
# o GDCquery: Searching in GDC database
# --------------------------------------
# Genome of reference: hg38
# --------------------------------------------
# oo Accessing GDC. This might take a while...
# --------------------------------------------
# ooo Project: TCGA-BRCA
# --------------------
# oo Filtering results
# --------------------
# ooo By data.type
# ----------------
# oo Checking data
# ----------------
# ooo Checking if there are duplicated cases
# ooo Checking if there are results for the query
# -------------------
# o Preparing output
# -------------------

# TCGAbiolinks::GDCdownload(harmonized.data)
# Downloading data for project TCGA-BRCA
# GDCdownload will download 1231 files. A total of 5.223473855 GB
# exp.se.obj <- TCGAbiolinks::GDCprepare(query = harmonized.data)

#----- save data for later use:
# qs::qsave(x = exp.se.obj, file = 'TCGA_BrCaRNAseq_StarCounts38_TCGAbiolinks.021424.qs')
```

We read the data, subset to protein coding genes, remove duplicated gene names, and set the row names to be gene names. Here you need to have `qs` package installed if your data format is in qs. 
```{r message=FALSE, warning=F}
exp.se.obj <- qs::qread(
    file = paste0(dataPath, 'TCGA_BrCaRNAseq_StarCounts38_TCGAbiolinks.021424.qs')
    )

gene.annot <- rowData(x = exp.se.obj)
# subset to protein coding genes
exp.se.obj <- exp.se.obj[ gene.annot$gene_type == 'protein_coding', ]
gene.annot <- rowData(x = exp.se.obj)
# remove duplicated gene names
exp.se.obj <- exp.se.obj[!duplicated(gene.annot$gene_name), ]
# set the row names to be gene names
row.names(exp.se.obj) <- rowData(x = exp.se.obj)$gene_name
```

## Batch information data
We also read in the batch data from Molania et al *Nat Biotech* (2023) paper. This data has different batch information (e.g. Year, Plate, Centre, etc) for all TCGA cancer data sets. We subset the batch data to Breast cancer only, and add those info to the `SummarizedExperiment` object. You need to have `readxl` package installed to rad the excel file. 
```{r message=FALSE, warning=F}
batch.info <- readxl::read_excel(
    path = paste0(dataPath, '41587_2022_1440_MOESM3_ESM.xlsx'), 
    sheet = 1, 
    skip = 1)
batch.info <- as.data.frame(batch.info)
# subset batch data to the breast cancer samples
index <- intersect(batch.info$Samples, colnames(exp.se.obj))
exp.se.obj <- exp.se.obj[ , index]
batch.info <- batch.info[batch.info$Samples %in% index, ]
## add batch information to the SummarizedExperiment Object
exp.se.obj$batch.years <- batch.info$Year
exp.se.obj$batch.plates <- batch.info$Plates
exp.se.obj$batch.FcCh <- 'FcCh.A'
exp.se.obj$batch.FcCh[exp.se.obj$batch.years > 2011] <- 'FcCh.B'
```


# Create a SummarizedExperiment object
In the above code, we already have a SE object; however, there may be situations where we have only one or several data sets in a form of data.frame/matrix. In these cases, we can generate a list of them, and use the `createSeObj()` function (see below) to create SE object followed by some filtration. The below code, attempts to generate a list of data sets. 
```{r}
selected.assays <- c(
    'unstranded', 
    'tpm_unstrand', 
    'fpkm_unstrand', 
    'fpkm_uq_unstrand')
data.sets <- lapply(
    selected.assays, 
    function(x) assay(x = exp.se.obj, i = x))
names(data.sets) <- selected.assays
sample.annotation <- as.data.frame(colData(exp.se.obj))
gene.annot <- as.data.frame(rowData(exp.se.obj))
colnames(gene.annot)[7] <- 'hgnc_symbol'
```

The `prepareSeObj()` function prepares the data and generates SummarizedExperiment object from a list of TCGA BrCa data sets. We remove lowly expressed genes, and estimate library size and tumor purity. 

Data preparation step includes:
  - filter genes
  - estimate purity
  - calculate library size
  - annotate genes based on whether or not they are housekeeping or immune genes

- **NOTE**: The function also needs to have an option to accept SE objects. If the input is not SE object, then the function can convert it to SE object. 

```{r createSeObj, message=FALSE, warning=F}
brca.se.obj <- prepareSeObj(
    data = data.sets, 
    raw.count.assay.name = 'unstranded', 
    gene.annotation = gene.annot,
    create.sample.annotation = FALSE,
    sample.annotation = sample.annotation,
    remove.lowly.expressed.genes = TRUE, 
    assay.name.to.estimate.purity = 'fpkm_uq_unstrand',
    estimate.tumor.purity = 'both',
    calculate.library.size = TRUE,
    add.housekeeping.genes = TRUE,
    add.immun.stroma.genes = TRUE,
    gene.group = 'hgnc_symbol', 
    verbose = TRUE
    )
names(assays(brca.se.obj)) <- c('RawCount', 'TPM', 'FPKM', 'FPKM.UQ')
```


# Variation assessment
We select the 'paper_BRCA_Subtype_PAM50' as a biological variation and the 'library.size', 'tumour.purity' and 
'batch_FcCh' as sources of unwanted variation.

In this section we will assess the variation of different biological and unwanted variables using a range of metrics. Before applying the metrics, we will assess the structure and missing values in the SummarizedExperiment object.

The results of all these assessments for each assay are saved under `brca.se.obj@metadata$metric`, and corresponding plots are saved under `brca.se.obj@metadata$plot`. All the assessment metrics that can be calculated for each of the selected variables can be visualised through the `getAssessmentMetrics()` function. 

```{r assessSeObject, message=FALSE, warning=F}
colnames(brca.se.obj@colData)[colnames(brca.se.obj@colData) == 'paper_BRCA_Subtype_PAM50'] <-
  'PAM50'

variables <-  c('PAM50',
                'library.size',
                'tumour.purity.estimate',
                'batch.FcCh')
  
brca.se.obj <- checkSeObj(
  se.obj = brca.se.obj,
  assay.names = 'all',
  variables = variables,
  remove.na = 'both',
  verbose = TRUE
)
```

```{r}
# Visualise all possible assessment metrics for the variables
brca.se.obj <- RUVIIIPRPS:::getAssessmentMetrics(
    se.obj = brca.se.obj, 
    variables = variables)

#--- export the plot
png(
  paste0(figPath, "Assessment_Matrix.png"),
  height = 9,
  width = 11,
  res = 300,
  units = "in"
)
RUVIIIPRPS:::getAssessmentMetrics(se.obj = brca.se.obj, variables = variables)
dev.off()
```

## RLE plot
Relative log expression (RLE) plots are useful ways to assess the unwanted variation in the data (see [Gandolfo et al, 2018](https://pubmed.ncbi.nlm.nih.gov/29401521/)). We first compute the RLE of all the assays in the SummarizedExperiment object. These values along with median and IQR are stored in the brca.se.obj. We then use these values to generate RLE plots, and examine associations of different variables with RLE medians/IQRs. The results are saved as part of `RLE` slot for each assay under `brca.se.obj@metadata$metric`. Corresponding plots are saved under `brca.se.obj@metadata$plot`.

```{r computeRLE, message=FALSE, warning=F}
assay.names <- c('RawCount','TPM','FPKM', 'FPKM.UQ')
brca.se.obj <- computeRLE(
    se.obj = brca.se.obj, 
    assay.names = assay.names, 
    apply.log = TRUE, 
    pseudo.count = 1, 
    outputs.to.return = 'all', 
    assess.se.obj = FALSE, 
    remove.na = 'none', 
    save.se.obj = TRUE)

# check the dimension of RLE matrix for FPKM assay; this is the same as the dimension of the brca.se.obj:
dim(brca.se.obj@metadata$metric$FPKM$RLE$rle.data$rle.data)
# 15321  1064
# check the vector of median RLE values for FPKM assay:
head(brca.se.obj@metadata$metric$FPKM$RLE$rle.data$rle.med)
# check the vector of IQR of RLE values for FPKM assay:
head(brca.se.obj@metadata$metric$FPKM$RLE$rle.data$rle.iqr)
```

We generate boxplots of the RLE data, i.e. RLE plots, and colour them based on different annotations in the data; this helps to examine different sources of unwanted variation. Here, we create colored RLE plot for the `batch_FcCh` as categorical variable. These plots are also saved as part of the SE object, and can be accessed for future use.

```{r}
brca.se.obj <-  RUVIIIPRPS::plotRLE(
    se.obj = brca.se.obj, 
    assay.names = assay.names, 
    variable = 'batch.FcCh', 
    ylim.rle.plot = NULL, 
    iqr.width = 1, 
    median.points.size = .5, 
    median.points.color = 'grey', 
    geom.hline.color = 'red', 
    plot.ncol = 2, 
    plot.nrow = 2, 
    plot.output = TRUE, 
    save.se.obj = TRUE, 
    verbose = TRUE)

# the coloured RLE plot for batch FcCh has been saved here:
# brca.se.obj@metadata$plot$RLE$colored.rle.plot$batch.FcCh
##---- export RLE plots
png(
  paste0(figPath, "RLE_plots_batch.FcCh.png"),
  height = 7,
  width = 12,
  res = 300,
  units = "in"
)
brca.se.obj@metadata$plot$RLE$colored.rle.plot$batch.FcCh
dev.off()

##--- for PAM50 biological variable
brca.se.obj <-  RUVIIIPRPS::plotRLE(
    se.obj = brca.se.obj, 
    assay.names = assay.names, 
    variable = 'PAM50', 
    ylim.rle.plot = NULL, 
    iqr.width = 1, 
    median.points.size = .5, 
    median.points.color = 'grey', 
    geom.hline.color = 'red', 
    plot.ncol = 2, 
    plot.nrow = 2, 
    plot.output = TRUE, 
    save.se.obj = TRUE, 
    verbose = TRUE)


png(
  paste0(figPath, "RLE_plots_PAM50.png"),
  height = 7,
  width = 12,
  res = 300,
  units = "in"
)
brca.se.obj@metadata$plot$RLE$colored.rle.plot$PAM50
dev.off()
```

### RLE medians and IQRs
We can also use the `plotRleVariable()` function to plot a selected variable against the medians and IQRs of the RLE data. This function, generates and saves scatterplots or boxplots depending on the input variables; for example:

- For a **categorical variable** (*e.g.* cancer subtypes and two batches of FcCh) the function generates boxplots and performs ANOVA analysis
- For a **continuous variable** (*e.g.* library size and tumour purity measurements) the function generates scatterplots and performs correlation analysis

```{r}
# For library size, we first log-transform them for better visualizations.
brca.se.obj$library.size <- log2(brca.se.obj$library.size)

for(i in variables){
    brca.se.obj <- plotRleVariable(
    se.obj = brca.se.obj, 
    assay.names = assay.names, 
    variable = i, 
    rle.data.type = 'both', 
    ylim.rle.med.plot = NULL, 
    ylim.rle.iqr.plot = NULL, 
    points.size = 1,  
    plot.ncol = 2, 
    plot.nrow = 2, 
    plot.output = TRUE, 
    save.se.obj = TRUE, 
    verbose = TRUE)
}

##------ export the plots
for (i in variables) {
  png(
    paste0(figPath, "RLE_Variable_plot_", i, ".png"),
    height = 6,
    width = 7,
    res = 300,
    units = "in"
  )
  print(brca.se.obj@metadata$plot$RLE$rle.var.plot[[i]])
  dev.off()
}

```

## PCA plot
In this section, we show how to perform PCA, and how to use the results of PCA to perform a range of exploratory analyses. These analyses are largely dependent on the type of variables being explored, more specifically categorical vs continuous variables:

- **Categorical variables**: 
    - PC and variable correlation (vector correlation)
    - Adjusted Rand index (ARI)
    - Silhouette coef
- **Continuous variables**:
    - PC variable regression 

The `computePCA()` function performs singular value decomposition, and calculates percentage variation of each PCs. This can be run on one assay or selected assays in the SE object; if assay is not selected, the function by default runs on all available assays. The default mode of this function is to run on a fast mode (`fast.pca = TRUE`), which means that it calculates a certain number of left singular vectors (based on `nb.pcs` argument) instead of the full possible vectors.
```{r}
brca.se.obj <- computePCA(
    se.obj = brca.se.obj, 
    assay.names = assay.names, 
    fast.pca = TRUE, 
    nb.pcs = 10, 
    center = TRUE, 
    scale = FALSE, 
    apply.log = TRUE, 
    pseudo.count = 1, 
    svd.bsparam = BiocSingular::bsparam(), 
    assess.se.obj = FALSE, 
    remove.na = 'none', 
    save.se.obj = TRUE, 
    verbose = TRUE)
```

Using the calculated PCs, we then generate scatterplots and boxplots to explore different sources of variations. 
We need to indicate a name of the column in the sample annotation of the SummarizedExperiment object.
If the `variable` argument is a continuous variable, the function creates scatterplots of PCs1-3 vs the selected variable. If `variable` is categorical, then the function generates pairwise scatterplots of PCs1-3 coloured by the selected categorical variable; if `plot.type = "boxplot"` for categorical variables, the function creates boxplots of PCs1-3 across the variable.

```{r}
## Uncomment the commented section to export the plots
# pdf(paste0(figPath, "PCA_Scatterplots.pdf"),
#     height = 8,
#     width = 7)
for (i in variables) {
#   print(
    brca.se.obj <- RUVIIIPRPS::plotPCA(
      se.obj = brca.se.obj,
      assay.names = 'all',
      variable = i,
      fast.pca = TRUE,
      nb.pcs = 3,
      plot.type = 'scatter',
      points.size = 1,
      stroke.color = 'gray',
      stroke.size = .2,
      points.alpha = .4,
      densities.alpha = .3,
      plot.ncol = c(3, 1),
      plot.nrow = c(4, 4),
      save.se.obj = TRUE,
      verbose = TRUE
    )
  # )
}
# dev.off()

## Change plot types to boxplots; this adds boxplots for the categorical variables:
# pdf(paste0(figPath, "PCA_Boxplots.pdf"),
#     height = 8,
#     width = 7)
for (i in variables) {
  # print(
    brca.se.obj <- RUVIIIPRPS::plotPCA(
      se.obj = brca.se.obj,
      assay.names = 'all',
      variable = i,
      fast.pca = TRUE,
      nb.pcs = 3,
      plot.type = 'boxplot',
      points.size = 1,
      stroke.color = 'gray',
      stroke.size = .2,
      points.alpha = .4,
      densities.alpha = .3,
      plot.ncol = c(3, 1),
      plot.nrow = c(4, 4),
      save.se.obj = TRUE,
      verbose = TRUE
    )
  # )
}
dev.off()

## check PCA scatterplots of all assays coloured by PAM50
# brca.se.obj@metadata$plot$PCA$fast.pca$PAM50$pca.var.scat.plot

# for(i in variables) {
#   cur_var_plot <- brca.se.obj@metadata$plot$PCA$fast.pca[[i]]
#   cur_var_plot_name <- grep("scat", names(cur_var_plot), value = T)
#   
#   png(
#     paste0(figPath, "PCA_", i, "_", cur_var_plot_name, ".png"),
#     height = 8,
#     width = 7,
#     res = 300,
#     units = "in"
#   )
#   print(cur_var_plot[cur_var_plot_name])
#   dev.off()
#   
#   ## if there are also boxplots available for the variable, plot that too
#   if (any(grepl("box", names(cur_var_plot)))) {
#     cur_var_plot_name <- grep("box", names(cur_var_plot), value = T)
#     
#     png(
#       paste0(figPath, "PCA_", i, "_", cur_var_plot_name, ".png"),
#       height = 6,
#       width = 7,
#       res = 300,
#       units = "in"
#     )
#     print(cur_var_plot[cur_var_plot_name])
#     dev.off()
#   }
# }
```

### PC Variable Correlation
Vector correlation analysis (**VCA**) performed by `computePCVariableCorrelation()` measures the associations between cumulative PCs and a selected **categorical variable**. 
Then, the `plotPCVariableCorrelation()` function visualises the results of vector correlation analysis in the form of lineplots, with each line representing the results from different assays/normalisations across cumulative PCs. A good normalisation must show a higher correlation values for the biological factors (*e.g.* PAM50) and lower correlation values for batch variables (*e.g.* batch.FcCh). The `VCA` results are saved in the metadata. 
```{r}
categorical.variables <- c('batch.FcCh', 'PAM50')
for (i in categorical.variables) {
  brca.se.obj <- computePCVariableCorrelation(
    se.obj = brca.se.obj,
    assay.names = 'all',
    variable = i,
    fast.pca = TRUE,
    nb.pcs = 10,
    save.se.obj = TRUE,
    verbose = TRUE
  )
}
```

```{r}
## uncomment the code to export the plot
# the plot can also be accessed through brca.se.obj@metadata$plot$VCA

# pdf(
#   paste0(figPath, "PC_VariableCorr_Lineplots.pdf"),
#   height = 5,
#   width = 6
# )
for (i in categorical.variables) {
  # print(
    brca.se.obj <- plotPCVariableCorrelation(
      se.obj = brca.se.obj,
      assay.names = 'all',
      variable = i,
      fast.pca = TRUE,
      nb.pcs = 10,
      plot.output = TRUE,
      save.se.obj = TRUE,
      verbose = TRUE
    )
  # )
}
# dev.off()
```

### PC Variable Regression
For **continuous variables**, we perform linear regression using `computePCVariableRegression()` to check their associations with first cumulative PCs. We then use `plotPCVariableRegression()` to generate linear regression analysis (**LRA**) lineplots of R^2 of the fitted linear models. A good nomalisation shows a smaller R^2 for continuous batch variables, such as library size. The `LRA` results are saved in the metadata. 
```{r}
continuous.variables <- c('library.size', 'tumour.purity.estimate')
for (i in continuous.variables) {
  brca.se.obj <- computePCVariableRegression(
    se.obj = brca.se.obj,
    assay.names = 'all',
    variable = i,
    fast.pca = TRUE,
    nb.pcs = 10,
    save.se.obj = TRUE,
    verbose = TRUE
  )
}
```

```{r}
pdf(
  paste0(figPath, "PC_VariableRegression_Lineplots.pdf"),
  height = 5,
  width = 6
)
for (i in continuous.variables) {
  print(
    brca.se.obj <- plotPCVariableRegression(
      se.obj = brca.se.obj,
      assay.names = 'all',
      variable = i,
      fast.pca = TRUE,
      nb.pcs = 10,
      save.se.obj = TRUE,
      plot.output = TRUE,
      verbose = TRUE
    )
  )
}
dev.off()
```

### Adjusted Rand Index (ARI)
We use the selected first PCs (`nb.pcs = 3` by default) to cluster samples. By calculating ARI between the generated clusters and **categorical variables** we can quantify how well each group in a given variable (e.g. batch.FcCh) map to each cluster. The number of clusters are defined based on the number of unique elements in the selected variables (e.g. two batches for batch.FcCh). We then use `plotARI()` to generate barplots of ARIs for each assay/normalisation. If a data is normalised well, we expect to see higher ARI for biology variable and lower ARI for batch variables, which means that main clusters in the data are associated with biology while batch effects are more randomly distributed. 
```{r}
for(i in categorical.variables){
    brca.se.obj <- computeARI(
    se.obj = brca.se.obj, 
    assay.names = assay.names, 
    variable = i, 
    fast.pca = TRUE,
    nb.pcs = 3, 
    clustering.method = 'hclust', 
    hclust.method = 'complete', 
    hclust.dist.measure = 'euclidian', 
    save.se.obj = TRUE, 
    verbose = TRUE)
}
```

```{r}
pdf(paste0(figPath, "ARI_Barplots.pdf"),
    height = 5,
    width = 5)
for (i in categorical.variables) {
  print(
    brca.se.obj <- plotARI(
      se.obj = brca.se.obj,
      assay.names = assay.names,
      variables = i,
      ari.method = 'hclust.complete.euclidian',
      plot.type = 'single.plot',
      plot.output = TRUE,
      save.se.obj = TRUE,
      verbose = TRUE
    )
  )
}
dev.off()

```

### Silhouette coefficient
The `computeSilhouette()` function calculates Silhouette coefficients to assess the cohesion and separation of **categorical variables** (biological or batch groups). This function uses Euclidean distance to calculate Silhouette coefficients based on:

- *Cohesion* (intra-cluster distance): average distance between each sample and all other samples in the same cluster
- *Separation* (nearest-cluster distance): average distance between each sample and all samples in the nearest cluster that the given sample is not a part of.

A good normalization results in a larger silhouette coefficient for biological variables, and smaller coefficient for batch variables. 
```{r}
for(i in categorical.variables){
    brca.se.obj <- computeSilhouette(
    se.obj = brca.se.obj, 
    assay.names = assay.names, 
    variable = i, 
    dist.measure = 'euclidian', 
    fast.pca = TRUE, 
    nb.pcs = 3, 
    save.se.obj = TRUE, 
    verbose = TRUE)
}

```

```{r}
pdf(paste0(figPath, "Silhouette_Barplots.pdf"),
    height = 5,
    width = 5)
for (i in categorical.variables) {
  print(
    brca.se.obj <- plotSilhouette(
      se.obj = brca.se.obj,
      assay.names = assay.names,
      variables = i,
      silhouette.method = 'sil.euclidian',
      plot.type = 'single.plot',
      plot.output = TRUE,
      save.se.obj = TRUE,
      verbose = TRUE
    )
  )
}
dev.off()
```

## Gene Variable Associations
In this section, we calculate the association between expression of individual genes and different variables. These results can be used to assess how well each normalisation performs. 

**NOTE to improve other functions based on this part:**: 
The results here could be used to help with defining negative control genes. So no need to calculate corr later on if we define them here. 

### Genes Variable Correlation
We calculate the correlation (Spearman or Pearson) between individual gene-level expression of each assay and a given **continuous variable**. Using `plotGenesVariableCorrelation()` we generate boxplots of all correlation values for each assay/normalisation. A good normalisation should result in a correlation boxplot whose medians are closer to zero for the batch variables (e.g. library size) with smaller IQRs, meaning that most genes are not correlated with batch variables. 
```{r}
for(i in continuous.variables){
    brca.se.obj <- computeGenesVariableCorrelation(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variable = i,
    method = 'spearman', 
    a = 0.05, 
    rho = 0, 
    apply.log = TRUE, 
    pseudo.count = 1 , 
    plot.top.genes = FALSE, 
    nb.top.genes = NULL,
    apply.round = TRUE, 
    assess.se.obj = FALSE, 
    remove.na = 'none', 
    save.se.obj = TRUE, 
    verbose = TRUE)
}

head(brca.se.obj@metadata$metric$FPKM$Correlation$spearman$library.size$cor.coef)
```


```{r}
pdf(
  paste0(figPath, "GeneVarAssociation_Boxplots.pdf"),
  height = 5,
  width = 5
)
for (i in continuous.variables) {
  print(
    brca.se.obj <- plotGenesVariableCorrelation(
      se.obj = brca.se.obj,
      assay.names = assay.names,
      variable = i,
      correlation.method = 'spearman',
      plot.output = TRUE,
      save.se.obj = TRUE,
      verbose = TRUE
    )
  )
}
dev.off()
```

### Genes Variable Anova
If we have **categorical variables**, we can examine the associations between genes and variables using the ANOVA test through the `computeGenesVariableAnova()` function. The results are visualised in form of boxplots. In this case, we expect to see a larger F statistic for biology variables, and a lower F value for batch variables for a good normalisation method. 
```{r}

for(i in categorical.variables){
   brca.se.obj <- computeGenesVariableAnova(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variable = i, 
    method = 'aov', 
    apply.log = TRUE,
    pseudo.count = 1, 
    plot.top.genes = FALSE,
    nb.top.genes = 3, 
    apply.round = FALSE,
    assess.se.obj = FALSE, 
    remove.na = 'none', 
    save.se.obj = TRUE, 
    verbose = TRUE) 
}
```

```{r}
pdf(paste0(figPath, "GeneVarANOVA_Boxplots.pdf"),
    height = 5,
    width = 5)
for (i in categorical.variables) {
  print(
    brca.se.obj <- plotGenesVariableAnova(
      se.obj = brca.se.obj,
      assay.names = assay.names,
      variable = i,
      anova.method = 'aov',
      plot.output = TRUE,
      save.se.obj = TRUE,
      verbose = TRUE
    )
  )
}
dev.off()
```

## Compute DGE
A good normalisation results in relatively larger number of Differential Gene Expression (DGE) when comparing biology groups and no/low number of DGE when comparing different groups of batch variables. The `computeDGE()` performs Wilcoxon test between pairwise groups of a variable for each assay/normalisation. The `plotDGE()` function generates p-value histograms for a given *categorical variable*.
```{r}
for(i in categorical.variables){
    brca.se.obj <- computeDGE(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variable = i, 
    apply.log = TRUE,
    pseudo.count = 1, 
    assess.se.obj = FALSE, 
    remove.na = 'none', 
    save.se.obj = TRUE, 
    verbose = TRUE)
}

```

```{r}
pdf(paste0(figPath, "DEGs_Hists.pdf"),
    height = 4,
    width = 12)
brca.se.obj <- plotDGE(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variable = 'batch.FcCh', 
    plot.ncol = 4, 
    plot.nrow = 1,
    plot.output = TRUE, 
    save.se.obj = TRUE, 
    verbose = FALSE)
dev.off()
```

# RUV-III-PRPS normalization
We need to define Negative Control Genes (Ncg) and pseudo-replicates of pseudo-samples. Here we show example of how to define data-driven NCGs. 

## Find NCGs (Supervised)
NCGs are genes whose expression is associated with unwanted variation but not with biological factor of interest. There are different ways to define these genes; here we show the supervised method. The associated functions, e.g. `findNcgSupervised()`, include five steps:

1. Pre-process the data (e.g. log2 transformation, library size normalisation, or regressing out biological or unwanted variation).
2. Creates all possible sample groups with respect to biological and unwanted variation separately.
3. Performs two-way ANOVA (or combination of ANOVA and correlation, see `approach` argument) for each of the groups of biological factors and unwanted variation separately to find genes associated with these factors. 
4. Summarizes the statistical outputs to select the top n number of genes as NCGs; methods for this step includes: `non.overlap` (default), `prod`, `average`, `sum`, and `auto`. 
5. Assesses the performance of NCGs (when `assess.ncg = TRUE`) 
This selects genes that are highly associated with unwanted variation (e.g. have high F-statistics) while have the low associations with biological variation.

To perform assessment of NCGs, the functiomn performs PCA using the selected NCGs, and then calculates the corr between cumulative PCs and NCGs in each groups. The lineplot viasualises the correlation between cumulative PCs and NCGs in each of the biological factor and unwanted variation. A good set of NCGs should show higher corr with unwanted variation and lower correlation with biological variation. You can change the `approach` argument and see how the assessment plot changes. There are three main approaches (`approach`) to select from:

- `TwoWayAnova`: calls `findNcgByTwoWayAnov()` to perform two-way ANOVA on two homogeneous groups of each of biological and unwanted variations.
- `AnovaCorr.AcrossAllSamples`: calls `findNcgAcrossSamples()` to compute gene-level ANOVA and correlation analysis on all samples and all biological and unwanted variation to find genes that are highly affected by categorical and continuous variables. 
- `AnovaCorr.PerBatchPerBio`: calls  `findNcgPerBiologyPerBatch()` to perform both the correlation and ANOVA within groups of samples that
are homogeneous with respect to biological or unwanted variation



```{r}
# pdf(paste0(figPath, "Assess_NCGs_TwoWayAnova.pdf"),
#     height = 5,
#     width = 6)
brca.se.obj <- findNcgSupervised(
    se.obj = brca.se.obj, 
    assay.name = 'RawCount', 
    approach = 'TwoWayAnova', 
    ncg.selection.method = 'non.overlap', 
    bio.variables = 'PAM50', 
    uv.variables = c('library.size', 'batch.FcCh', 'tumour.purity.estimate'), 
    output.name = 'ctrl_2wayanova', 
    assess.ncg = TRUE)
# dev.off()
```



## Find PRPS (Supervised)
To have define technical replicates we use the pseudo-replicates of pseudo-samples (PRPS) approach. Each PRPS needs to have at least two PS, and each UV can have multiple sets of PRPS. There are supervised and unsupervised approaches to define PRPS.

The `createPrPsSupervised()` function is used when we know the sources of unwanted variation and biology. PRPS can be created for individual sources of unwanted variation with or without taking into account the other sources of unwanted variation. Rhis function creates several groups of pseudo-samples by averaging the samples of the same biological subtype defined in `bio.variables` in each batch, defined in `uv.variables` argument.
```{r}
# pdf(paste0(figPath, "Visualise_PRPS.pdf"),
#     height = 5,
#     width = 10)
brca.se.obj <- createPrPsSupervised(
    se.obj = brca.se.obj, 
    assay.name = 'RawCount', 
    bio.variables = 'PAM50', 
    uv.variables = c('library.size', 'batch.FcCh', 'tumour.purity.estimate'), 
    apply.other.uv.variables = TRUE,
    nb.bio.clusters = 3, 
    nb.other.uv.clusters = 3, 
    assess.se.obj = FALSE, 
    remove.na = 'none', 
    save.se.obj = TRUE, 
    plot.output = TRUE, 
    prps.set.name = 'Set2', #	TTT messages displayed during the execution of the functions, by default it is set to TRUE. BUT Default is NULL??
    verbose = TRUE)
# dev.off()
# WHY?
# brca.se.obj@metadata$PRPS <- NULL
```

## Run Normalisation
This function uses the NCGs and PRPS defined above to normalise the data; we can include several Ks (dimension of unwanted variation) to examine which k performs better. 
```{r}
brca.se.obj <- RUVIII.PRPS(
    se.obj = brca.se.obj, 
    assay.name = 'RawCount', 
    prps.group = 'supervised', 
    ncg.group = 'supervised', 
    k = c(1,10,15,20), 
    return.info = TRUE, 
    assess.se.obj = FALSE, 
    remove.na = 'none', 
    save.se.obj = TRUE)
```

## Assess Variarion
The result of `RUVIII.PRPS()` function abive is log transformed; to be able to run several assessments, we need to have all the assays log transformed too. We use `createLogAssays()` function for this purpose.

The `assessVariation()` function that applies both global (e.g. PCA, RLE, ARI) and gene-level (e.g. DEGs, ANOVA, correlation) assessments.
```{r}
dd <- names(assays(brca.se.obj))[1:4]
brca.se.obj <- RUVIIIPRPS:::createLogAssays(
    se.obj = brca.se.obj, 
    assay.names = dd, 
    pseudo.count = 1, 
    replace.assays = TRUE, 
    apply.round = TRUE, 
    verbose = TRUE
    )


brca.se.obj <- assessVariation(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variables = variables, 
    apply.log = F
    )

getwd()
```

```{r}
brca.se.obj <- assessNormalization(
  se.obj = brca.se.obj,
  assay.names = "all",
  bio.variables = c('PAM50', 'batch.FcCh'),
  uv.variables = c('library.size', 'tumour.purity.estimate')
)
```







### unsupervised
In this approach  the biological factors and/or unwanted variation are not known. So the function has two approaches to find similar samples across known or estimated batches ()see `approach` argument: 

- A combination of k-nearest neighbor (knn) and mutual nearest neighbors (mnn) 
- Applies `findIntegrationAnchor()` from the `Seurat` package
```{r}
brca.se.obj <- createPrPsUnSupervised(
  se.obj = brca.se.obj,
  assay.name = 'RawCount',
  approach = 'mnn',
  uv.variables = c('library.size')
)
```



