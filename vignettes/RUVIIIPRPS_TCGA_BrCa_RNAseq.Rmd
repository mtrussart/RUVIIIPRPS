---
title: "Fast and accurate integration of TCGA BRCA RNA-seq data using the RUVIIIPRPS R package"
author:
- name: Ramyar Molania & Sepideh Foroutan
  affiliation: Papenfuss Lab, Bioinformatics, WEHI.
  url: https://www.wehi.edu.au/people/tony-papenfuss
date: "15-02-2020"
output:
  rmdformats::readthedown:
    code_folding: hide
    gallery: yes
    highlight: tango
    lightbox: yes
    self_contained: no
    thumbnails: no
    number_sections: yes
    toc_depth: 3
    use_bookdown: yes
  html_document2:
    df_print: paged
  html_document:
    toc_depth: '3'
    df_print: paged
params:
  update_date: !r paste("Last updated on:", Sys.Date())
editor_options:
  chunk_output_type: console
---
`r params$update_date`

<style type="text/css">
h1.title {
  font-size: 28px;
  color: DarkRed;
}
h1 { /* Header 1 */
  font-size: 24px;
  color: DarkBlue;
}
h2 { /* Header 2 */
    font-size: 20px;
  color: DarkBlue;
}
h3 { /* Header 3 */
    font-size: 18px;
  color: DarkBlue;
}
h4 { /* Header 3 */
    font-size: 16px;
  color: DarkBlue;
}
</style>

<style>
p.caption {
  font-size: 46em;
  font-style: italic;
  color: black;
}
</style>

```{r knitr_init, echo=FALSE, results="asis"}
library(knitr)
library(rmdformats)
library(DT)
library(BiocStyle)
```

```{r setup, include=F}
knitr::opts_chunk$set(
  tidy = FALSE,
  fig.width = 10,
  message = FALSE,
  warning = FALSE
)
```

# Introduction
In this vignette, we showed how to use the RUVIIIPRPS R package to normalize the TCGA breast cancer RNA-seq data.
First, we install RUVIIIPRPS package. You may need to install several dependencies first (see commented codes below) to be able to install the RUVIIIPRPS package. In this section, we also load required libraries and set the required paths.
## Install packages and set paths
```{r}
library(devtools)
library(SummarizedExperiment)

devtools::install_github(
    repo = 'RMolania/RUVIIIPRPS@Ramyar-M',
    force = TRUE,
    build_vignettes = FALSE)
# ERROR: dependencies ‘ggforestplot’, ‘qvalue’, ‘singscore’, ‘kunstomverse’, ‘SummarizedExperiment’, ‘BiocNeighbors’, ‘EDASeq’, ‘DESeq2’, ‘biomaRt’ are not available for package ‘RUVIIIPRPS’

# BiocManager::install(
#   c(
#     'ggforestplot',
#     'qvalue',
#     'singscore',
#     'kunstomverse',
#     'SummarizedExperiment',
#     'BiocNeighbors',
#     'EDASeq',
#     'DESeq2',
#     'biomaRt'
#   )
# )
## need to install two packages from Github: 
# devtools::install_github("NightingaleHealth/ggforestplot")
# devtools::install_github("jbkunst/kunstomverse")

library(RUVIIIPRPS)

# Error: package or namespace load failed for ‘RUVIIIPRPS’ in loadNamespace(j <- i[[1L]], c(lib.loc, .libPaths()), versionCheck = vI[[j]]):
#  namespace ‘tidyselect’ 1.2.0 is already loaded, but >= 1.2.1 is required

## change this path according to your computer path:
dataPath <- "/Users/sep/Documents/projects/RUVIIIPRPS_manual/data/"
```

 
# Download the data using the TCGAbiolinks R package

# Download, read and prepare the data
## TCGA-BRCA data
The TCGA Breast cancer data can be downloaded from the `TCGAbiolinks` package. The commented code below needs to be run only once to download the data, and for later use we can load the downloaded data.

```{r downloadingTheData, message=F, warning=F}
# harmonized.data <- TCGAbiolinks::GDCquery(
#     project = 'TCGA-BRCA',
#     data.category = 'Transcriptome Profiling',
#     data.type = 'Gene Expression Quantification'
#     )
# --------------------------------------
# o GDCquery: Searching in GDC database
# --------------------------------------
# Genome of reference: hg38
# --------------------------------------------
# oo Accessing GDC. This might take a while...
# --------------------------------------------
# ooo Project: TCGA-BRCA
# --------------------
# oo Filtering results
# --------------------
# ooo By data.type
# ----------------
# oo Checking data
# ----------------
# ooo Checking if there are duplicated cases
# ooo Checking if there are results for the query
# -------------------
# o Preparing output
# -------------------

# TCGAbiolinks::GDCdownload(harmonized.data)
# Downloading data for project TCGA-BRCA
# GDCdownload will download 1231 files. A total of 5.223473855 GB
# exp.se.obj <- TCGAbiolinks::GDCprepare(query = harmonized.data)

#----- save data for later use:
# qs::qsave(x = exp.se.obj, file = 'TCGA_BrCaRNAseq_StarCounts38_TCGAbiolinks.021424.qs')
```

We read the data, subset to protein coding genes, remove duplicated gene names, and set the row names to be gene names.
```{r message=FALSE, warning=F}
exp.se.obj <- qs::qread(
    file = paste0(dataPath, 'TCGA_BrCaRNAseq_StarCounts38_TCGAbiolinks.021424.qs')
    )

gene.annot <- rowData(x = exp.se.obj)
# subset to protein coding genes
exp.se.obj <- exp.se.obj[ gene.annot$gene_type == 'protein_coding', ]
gene.annot <- rowData(x = exp.se.obj)
# remove duplicated gene names
exp.se.obj <- exp.se.obj[!duplicated(gene.annot$gene_name), ]
# set the row names to be gene names
row.names(exp.se.obj) <- rowData(x = exp.se.obj)$gene_name
```

## Batch information data
We also read in the batch data from Molania et al *Nat Biotech* (2023) paper. This data has different batch information (e.g. Year, Plate, Centre, etc) for all TCGA cancer data sets. We subset the batch data to Breast cancer only, and add those info to the `SummarizedExperiment` object. 
```{r message=FALSE, warning=F}
batch.info <- readxl::read_excel(
    path = paste0(dataPath, '41587_2022_1440_MOESM3_ESM.xlsx'), 
    sheet = 1, 
    skip = 1)
batch.info <- as.data.frame(batch.info)
# subset batch data to the breast cancer samples
index <- intersect(batch.info$Samples, colnames(exp.se.obj))
exp.se.obj <- exp.se.obj[ , index]
batch.info <- batch.info[batch.info$Samples %in% index, ]
## add batch information to the SummarizedExperiment Object
exp.se.obj$batch.years <- batch.info$Year
exp.se.obj$batch.plates <- batch.info$Plates
exp.se.obj$batch.FcCh <- 'FcCh.A'
exp.se.obj$batch.FcCh[exp.se.obj$batch.years > 2011] <- 'FcCh.B'
```


# Create a SummarizedExperiment object
In the above code, we already have a SE object; however, there may be situations where we have only one or several data sets in a form of data.frame/matrix. In these cases, we can generate a list of them, and use the `createSeObj()` function (see below) to create SE object followed by some filtration. The below code, attempts to generate a list of data sets. 
```{r}
selected.assays <- c(
    'unstranded', 
    'tpm_unstrand', 
    'fpkm_unstrand', 
    'fpkm_uq_unstrand')
data.sets <- lapply(
    selected.assays, 
    function(x) assay(x = exp.se.obj, i = x))
names(data.sets) <- selected.assays
sample.annotation <- as.data.frame(colData(exp.se.obj))
gene.annot <- as.data.frame(rowData(exp.se.obj))
colnames(gene.annot)[7] <- 'hgnc_symbol'
```

The `createSeObj()` function generates SummarizedExperiment object from a list of TCGA BrCa data sets. We remove lowly expressed genes, and estimate library size and tumor purity. 

**NOTE to improve the function:** 
- Change the name of the function to something like prepareSeObj() or prepraeData() as this function not only can create SE object from a list of data sets, but has several options to add more information to the data. These includes:

  - filter genes
  - estimate purity
  - calculate library size
  - annotate genes based on whether or not they are housekeeping or immune genes

- The function also needs to have an option to accept SE objects. If the input is not SE object, then the function can convert it to SE object. 

```{r createSeObj, message=FALSE, warning=F}
brca.se.obj <- createSeObj(
    data.sets = data.sets, 
    raw.count.assay.name = 'unstranded', 
    gene.annotation = gene.annot,
    create.sample.annotation = FALSE,
    sample.annotation = sample.annotation,
    remove.lowly.expressed.genes = TRUE, 
    assay.name.to.estimate.purity = 'fpkm_uq_unstrand',
    estimate.tumor.purity = 'both',
    calculate.library.size = TRUE,
    add.housekeeping.genes = TRUE,
    add.immun.stroma.genes = TRUE,
    gene.group = 'hgnc_symbol', 
    verbose = TRUE
    )
names(assays(brca.se.obj)) <- c('RawCount', 'TPM', 'FPKM', 'FPKM.UQ')
```


# Variation assessment
We select the 'paper_BRCA_Subtype_PAM50' as a biological variation and the 'library.size', 'tumour.purity' and 
'batch_FcCh' as sources of unwanted variation.

In this section we will assess the variation of different biological and unwanted variables using a range of metrics. Before applying the metrics, we will assess the structure and missing values in the SummarizedExperiment object.

The results of all these assessments for each assay are saved under `brca.se.obj@metadata$metric`, and corresponding plots are saved under `brca.se.obj@metadata$plot`. All the assessment metrics that can be calculated for each of the selected variables can be visualised through the `getAssessmentMetrics()` function. 

```{r assessSeObject, message=FALSE, warning=F}
colnames(brca.se.obj@colData)[colnames(brca.se.obj@colData) == 'paper_BRCA_Subtype_PAM50'] <-
  'PAM50'

brca.se.obj <- checkSeObj(
  se.obj = brca.se.obj,
  assay.names = 'all',
  variables = c(
    'PAM50',
    'library.size',
    'tumour.purity.estimate',
    'batch.FcCh'
  ),
  remove.na = 'both',
  verbose = TRUE
)
```

```{r}
# Visualise all possible assessment metrics for the variables
brca.se.obj <- RUVIIIPRPS:::getAssessmentMetrics(
    se.obj = brca.se.obj, 
    variables = variables)

```

## RLE plot
Relative log expression (RLE) plots are useful ways to assess the unwanted variation in the data (see [Gandolfo et al, 2018](https://pubmed.ncbi.nlm.nih.gov/29401521/)). We first compute the RLE of all the assays in the SummarizedExperiment object. These values along with median and IQR are stored in the brca.se.obj. We then use these values to generate RLE plots, and examine associations of different variables with RLE medians/IQRs. The results are saved as part of `RLE` slot for each assay under `brca.se.obj@metadata$metric`. Corresponding plots are saved under `brca.se.obj@metadata$plot`.

```{r computeRLE, message=FALSE, warning=F}
assay.names <- c('RawCount','TPM','FPKM', 'FPKM.UQ')
brca.se.obj <- computeRLE(
    se.obj = brca.se.obj, 
    assay.names = assay.names, 
    apply.log = TRUE, 
    pseudo.count = 1, 
    outputs.to.return = 'all', 
    assess.se.obj = FALSE, 
    remove.na = 'none', 
    save.se.obj = TRUE)

# check the dimension of RLE matrix for FPKM assay; this is the same as the dimension of the brca.se.obj:
dim(brca.se.obj@metadata$metric$FPKM$RLE$rle.data$rle.data)
# 15321  1064
# check the vector of median RLE values for FPKM assay:
head(brca.se.obj@metadata$metric$FPKM$RLE$rle.data$rle.med)
# check the vector of IQR of RLE values for FPKM assay:
head(brca.se.obj@metadata$metric$FPKM$RLE$rle.data$rle.iqr)
```

We generate boxplots of the RLE data, i.e. RLE plots, and colour them based on different sources of variation in the data; this helps to examine different sources of unwanted variation. Here, we create colored RLE plot for the `batch_FcCh` as categorical variable. These plots are also saved as part of the SE object, and can be accessed for future use.

```{r}
brca.se.obj <- plotRLE(
    se.obj = brca.se.obj, 
    assay.names = assay.names, 
    variable = 'batch.FcCh', 
    ylim.rle.plot = NULL, 
    iqr.width = 1, 
    median.points.size = .5, 
    median.points.color = 'grey', 
    geom.hline.color = 'red', 
    plot.ncol = 2, 
    plot.nrow = 2, 
    plot.output = TRUE, 
    save.se.obj = TRUE, 
    verbose = TRUE)

# the coloured RLE plot for batch FcCh has been saved here:
# brca.se.obj@metadata$plot$RLE$colored.rle.plot$batch.FcCh
```

### RLE medians and IQRs
We can also use the `plotRleVariable()` function to plot a selected variable against the medians and IQRs of the RLE data. This function, generates and saves scatterplots or boxplots depending on the input variables; for example:

- For a **categorical variable** (*e.g.* cancer subtypes and two batches of FcCh) the function generates boxplots and performs ANOVA analysis
- For a **continuous variable** (*e.g.* library size and tumour purity measurements) the function generates scatterplots and performs correlation analysis

```{r}
# For library size, we first log-transform them for better visualizations.
brca.se.obj$library.size <- log2(brca.se.obj$library.size)

variables <- c(
        'PAM50', 
        'library.size', 
        'tumour.purity.estimate', 
        'batch.FcCh')

for(i in variables){
    brca.se.obj <- plotRleVariable(
    se.obj = brca.se.obj, 
    assay.names = assay.names, 
    variable = i, 
    rle.data.type = 'both', 
    ylim.rle.med.plot = NULL, 
    ylim.rle.iqr.plot = NULL, 
    points.size = 1,  
    plot.ncol = 2, 
    plot.nrow = 2, 
    plot.output = TRUE, 
    save.se.obj = TRUE, 
    verbose = TRUE)
}
```

## PCA plot
In this section, we show how to perform PCA, and how to use the results of PCA to perform a range of exploratory analyses. These analyses are largely dependent on the type of variables being explored, more specifically categorical vs continuous variables:

- **Categorical variables**: 
    - PC and variable correlation (vector correlation)
    - Adjusted Rand index (ARI)
    - Silhouette coef
- **Continuous variables**:
    - PC variable regression 

The `computePCA()` function performs singular value decomposition, and calculates percentage variation of each PCs. This can be run on one assay or selected assays in the SE object; if assay is not selected, the function by default runs on all available assays. The default mode of this function is to run on a fast mode (`fast.pca = TRUE`), which means that it calculates a certain number of left singular vectors (based on `nb.pcs` argument) instead of the full possible vectors.
```{r}
brca.se.obj <- computePCA(
    se.obj = brca.se.obj, 
    assay.names = assay.names, 
    fast.pca = TRUE, 
    nb.pcs = 10, 
    center = TRUE, 
    scale = FALSE, 
    apply.log = TRUE, 
    pseudo.count = 1, 
    svd.bsparam = BiocSingular::bsparam(), 
    assess.se.obj = FALSE, 
    remove.na = 'none', 
    save.se.obj = TRUE, 
    verbose = TRUE)
```

Using the calculated PCs, we then generate scatterplots and boxplots to explore different sources of variations. 
Indicates a name of the column in the sample annotation of the SummarizedExperiment object.
If the `variable` argument is a continuous variable, the function creates scatterplots of PCs1-3 vs the selected variable. If `variable` is categorical, then the function generates pairwise scatterplots of PCs1-3 coloured by the selected categorical variable; if `plot.type = "boxplot"` for categorical variables, the function creates boxplots of PCs1-3 across the variable.

**NOTE to improve `plotPCA()`**:
Currently, when `plot.type = "boxplot"` this does not print the boxplots. Need to be updated s that prints the plot.  
```{r}
for(i in variables){
    brca.se.obj <- RUVIIIPRPS::plotPCA(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variable = i, 
    fast.pca = TRUE, 
    nb.pcs = 3,
    plot.type = 'scatter',
    points.size = 1, 
    stroke.color = 'gray', 
    stroke.size = .2, 
    points.alpha = .4, 
    densities.alpha = .3, 
    plot.ncol = c(3, 1),
    plot.nrow = c(4, 4),
    save.se.obj = TRUE, 
    verbose = TRUE)
}

## check PCA scatterplots of all assays coloured by PAM50
brca.se.obj@metadata$plot$PCA$fast.pca$PAM50$pca.scat.plot
```

### PC Variable Correlation
Vector correlation performed by `computePCVariableCorrelation()` measures the associations between cumulative PCs and a selected **categorical variable**. 
Then, the `plotPCVariableCorrelation()` function visualises the results of vector correlation analysis in the form of lineplots, with each line representing the results from different assays/normalisations across cumulative PCs. A good normalisation must show a higher correlation values for the biological factors (*e.g.* PAM50) and lower correlation values for batch variables (*e.g.* batch.FcCh). The `VCA` results are saved in the metadata. 
```{r}
categorical.variables <- c('batch.FcCh', 'PAM50')
for (i in categorical.variables) {
  brca.se.obj <- computePCVariableCorrelation(
    se.obj = brca.se.obj,
    assay.names = 'all',
    variable = i,
    fast.pca = TRUE,
    nb.pcs = 10,
    save.se.obj = TRUE,
    verbose = TRUE
  )
}
```

```{r}
for(i in categorical.variables){
    brca.se.obj <- plotPCVariableCorrelation(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variable = i, 
    fast.pca = TRUE, 
    nb.pcs = 10, 
    plot.output = TRUE, 
    save.se.obj = TRUE, 
    verbose = TRUE)
}
```

### PC Variable Regression
For **continuous variables**, we perform linear regression using `computePCVariableRegression()` to check their associations with first cumulative PCs. We then use `plotPCVariableRegression()` to generate linear regression anaysis (LRA) lineplots of R^2 of the fitted linear models. A good nomalisation shows a smaller R^2 for continuous batch variables, such as library size. The `LRA` results are saved in the metadata. 
```{r}
continuous.variables <- c('library.size', 'tumour.purity.estimate')
for (i in continuous.variables) {
  brca.se.obj <- computePCVariableRegression(
    se.obj = brca.se.obj,
    assay.names = 'all',
    variable = i,
    fast.pca = TRUE,
    nb.pcs = 10,
    save.se.obj = TRUE,
    verbose = TRUE
  )
}
```

```{r}
for(i in continuous.variables){
    brca.se.obj <- plotPCVariableRegression(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variable = i, 
    fast.pca = TRUE, 
    nb.pcs = 10, 
    save.se.obj = TRUE, 
    plot.output = TRUE, 
    verbose = TRUE)
}
```

### Adjusted Rand Index (ARI)
We use the selected first PCs (`nb.pcs = 3` by default) to cluster samples. By calculating ARI between the generated clusters and **categorical variables** we can quantify how well each group in a given variable (e.g. batch.FcCh) map to each cluster. The number of clusters are defined based on the number of unique elements in the selected variables (e.g. two batches for batch.FcCh). We then use `plotARI()` to generate barplots of ARIs for each assay/normalisation. If a data is normalised well, we expect to see higher ARI for biology variable and lower ARI for batch variables, which means that main clusters in the data are associated with biology while batch effects are more randomly distributed. 
```{r}
for(i in categorical.variables){
    brca.se.obj <- computeARI(
    se.obj = brca.se.obj, 
    assay.names = assay.names, 
    variable = i, 
    fast.pca = TRUE,
    nb.pcs = 3, 
    clustering.method = 'hclust', 
    hclust.method = 'complete', 
    hclust.dist.measure = 'euclidian', 
    save.se.obj = TRUE, 
    verbose = TRUE)
}
```

```{r}
for(i in categorical.variables){
    brca.se.obj <- plotARI(
    se.obj = brca.se.obj, 
    assay.names = assay.names, 
    variables = i, 
    ari.method = 'hclust.complete.euclidian', 
    plot.type = 'single.plot', 
    plot.output = TRUE, 
    save.se.obj = TRUE, 
    verbose = TRUE)
}

```

### Silhouette coefficient
The `computeSilhouette()` function calculates Silhouette coefficients to assess the cohesion and separation of **categorical variables** (biological or batch groups). This function uses Euclidean distance to calculate Silhouette coefficients based on:

- *Cohesion* (intra-cluster distance): average distance between each sample and all other samples in the same cluster
- *Separation* (nearest-cluster distance): average distance between each sample and all samples in the nearest cluster that the given sample is not a part of.

A good normalization results in a larger silhouette coefficient for biological variables, and smaller coefficient for batch variables. 
```{r}
for(i in categorical.variables){
    brca.se.obj <- computeSilhouette(
    se.obj = brca.se.obj, 
    assay.names = assay.names, 
    variable = i, 
    dist.measure = 'euclidian', 
    fast.pca = TRUE, 
    nb.pcs = 3, 
    save.se.obj = TRUE, 
    verbose = TRUE)
}

```

**NOTE to improve `plotSilhouette()`**:
Change the function so that when `plot.output = TRUE`, we do not plot the barplots for each assay separately.
```{r}
for(i in categorical.variables){
    brca.se.obj <- plotSilhouette(
    se.obj = brca.se.obj, 
    assay.names = assay.names,
    variables = i, 
    silhouette.method = 'sil.euclidian', 
    plot.type = 'single.plot', 
    plot.output = TRUE, 
    save.se.obj = TRUE, 
    verbose = TRUE)
}
```

## Gene Variable Associations
In this section, we calculate the association between expression of individual genes and different variables. These results can be used to assess how well each normalisation performs. 

**NOTE to improve other functions based on this part:**: 
The results here could be used to help with defining negative control genes. So no need to calculate corr later on if we define them here. 

### Genes Variable Correlation
We calculate the correlation (Spearman or Pearson) between individual gene-level expression of each assay and a given **continuous variable**. Using `plotGenesVariableCorrelation()` we generate boxplots of all correlation values for each assay/normalisation. A good normalisation should result in a correlation boxplot whose medians are closer to zero for the batch variables (e.g. library size) with smaller IQRs, meaning that most genes are not correlated with batch variables. 
```{r}
for(i in continuous.variables){
    brca.se.obj <- computeGenesVariableCorrelation(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variable = i,
    method = 'spearman', 
    a = 0.05, 
    rho = 0, 
    apply.log = TRUE, 
    pseudo.count = 1 , 
    plot.top.genes = FALSE, 
    nb.top.genes = NULL,
    apply.round = TRUE, 
    assess.se.obj = FALSE, 
    remove.na = 'none', 
    save.se.obj = TRUE, 
    verbose = TRUE)
}

head(brca.se.obj@metadata$metric$FPKM$Correlation$spearman$library.size$cor.coef)
```


```{r}
for(i in continuous.variables){
    brca.se.obj <- plotGenesVariableCorrelation(
    se.obj = brca.se.obj, 
    assay.names = assay.names, 
    variable = i, 
    correlation.method = 'spearman', 
    plot.output = TRUE, 
    save.se.obj = TRUE, 
    verbose = TRUE)
}
```

### Genes Variable Anova
If we have **categorical variables**, we can examine the associations between genes and variables using the ANOVA test through the `computeGenesVariableAnova()` function. The results are visualised in form of boxplots. In this case, we expect to see a larger F statistic for biology variables, and a lower F value for batch variables for a good normalisation method. 
```{r}
for(i in categorical.variables){
   brca.se.obj <- computeGenesVariableAnova(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variable = i, 
    method = 'aov', 
    apply.log = TRUE,
    pseudo.count = 1, 
    plot.top.genes = FALSE,
    nb.top.genes = 3, 
    apply.round = FALSE,
    assess.se.obj = FALSE, 
    remove.na = 'none', 
    save.se.obj = TRUE, 
    verbose = TRUE) 
}
```

```{r}
for(i in categorical.variables){
    brca.se.obj <- plotGenesVariableAnova(
    se.obj = brca.se.obj, 
    assay.names = assay.names, 
    variable = i, 
    anova.method = 'aov', 
    plot.output = TRUE, 
    save.se.obj = TRUE, 
    verbose = TRUE)
}
```

## Compute DGE
A good normalisation results in relatively larger number of Differential Gene Expression (DGE) when comparing biology groups and no/low number of DGE when comparing different groups of batch variables. The `computeDGE()` performs Wilcoxon test between pairwise groups of a variable for each assay/normalisation. The `plotDGE()` function generates p-value histograms for a given *categorical variable*.
```{r}
for(i in categorical.variables){
    brca.se.obj <- computeDGE(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variable = i, 
    apply.log = TRUE,
    pseudo.count = 1, 
    assess.se.obj = FALSE, 
    remove.na = 'none', 
    save.se.obj = TRUE, 
    verbose = TRUE)
}

```

```{r}
brca.se.obj <- plotDGE(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variable = 'batch.FcCh', 
    plot.ncol = 4, 
    plot.nrow = 1,
    plot.output = TRUE, 
    save.se.obj = TRUE, 
    verbose = FALSE)
```


# RUV-III-PRPS normalization
## Find NCGs
```{r}
brca.se.obj <- findNCGsSupervised(
    se.obj = brca.se.obj, 
    assay.name = 'unstranded', 
    approach = 'TWAnova', 
    ncg.selection.method = 'noneOverlap', 
    bio.variables = 'PAM50', 
    uv.variables = c('library.size', 'batch.FcCh', 'tumour.purity.estimate'), 
    nb.ncg = 10, 
    grid.nb = 1, 
    top.rank.bio.genes = 85, 
    top.rank.uv.genes = 70, 
    bio.groups = NULL, 
    nb.bio.clusters = 3, 
    bio.clustering.method = 'kmeans', 
    uv.groups = NULL, 
    nb.uv.clusters = 3, 
    uv.clustering.method = 'kmeans', 
    normalization = 'CPM', 
    regress.out.uv.variables = NULL, 
    regress.out.bio.variables = NULL, 
    apply.log = TRUE, 
    pseudo.count = 1,
    min.sample.for.aov = 3, 
    min.sample.for.correlation = 10, 
    corr.method = 'spearman', 
    a = 0.05, 
    rho = 0, 
    anova.method = 'aov',
    assess.ncg = TRUE, 
    variables.to.assess.ncg = NULL, 
    nb.pcs = 10, 
    center = TRUE, 
    scale = FALSE, 
    assess.se.obj = FALSE,
    assess.variables = FALSE, 
    remove.na = 'none', 
    save.se.obj = TRUE, 
    verbose = TRUE)
brca.se.obj@metadata$NCG$supervised$
```

```{r}
brca.se.obj <- createSupervisedPRPS(
    se.obj = brca.se.obj, 
    assay.name = 'unstranded', 
    bio.variables = 'PAM50', 
    uv.variables = c('library.size', 'batch.FcCh', 'tumour.purity.estimate'), 
    apply.other.uv.variables = TRUE, 
    min.sample.for.prps = 3, 
    bio.clustering.method = 'kmeans', 
    nb.bio.clusters = 3, 
    other.uv.clustering.method = 'kmeans', 
    nb.other.uv.clusters = 3, 
    check.prps.connectedness = TRUE, 
    apply.log = TRUE, 
    pseudo.count = 1, 
    assess.se.obj = FALSE, 
    assess.variables = FALSE, 
    remove.na = 'none', 
    save.se.obj = TRUE, 
    plot.output = TRUE, 
    verbose = TRUE)
brca.se.obj@metadata$NCG$supervised$
```

```{r}
brca.se.obj <- RUVIII.PRPS(
    se.obj = brca.se.obj, 
    assay.name = 'unstranded', 
    prps.group = 'supervised', 
    prps.set.names = NULL,
    ncg.group = 'supervised', 
    ncg.set.names = NULL, 
    k = c(1,10,15, 20), 
    apply.log = 'assay', 
    pseudo.count = 1, 
    alpha = NULL,
    eta = NULL, 
    include.intercept = TRUE, 
    return.info = TRUE, 
    assess.se.obj = FALSE, 
    remove.na = 'none', 
    save.se.obj = TRUE)
```

```{r}
dd <- names(assays(brca.se.obj))[1:4]
brca.se.obj <- RUVIIIPRPS:::createLogAssays(
    se.obj = brca.se.obj, 
    assay.names = dd, 
    pseudo.count = 1, 
    replace.assays = TRUE, 
    apply.round = TRUE, 
    verbose = TRUE
    )


brca.se.obj <- assessVariation(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variables = variables, 
    bio.variables = c('PAM50', 'batch.FcCh'), 
    uv.variables = c('library.size', 'tumour.purity.estimate'), 
    apply.log = F
    )

```

## RLE plot
We first compute of the RLE of all the assays in the SummarizedExperiment object.
```{r computeRLE, message=FALSE, warning=F}
brca.se.obj <- computeRLE(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    apply.log = FALSE, 
    pseudo.count = 1, 
    outputs.to.return = 'all', 
    assess.se.obj = FALSE, 
    remove.na = 'none', 
    save.se.obj = TRUE)
```
Then, we explore the association of the RLE data with sources of unwanted variation. Here, we create colored RLE plot for
the 'batch_FcCh' as categorical variable.

```{r}
brca.se.obj <- plotRLE(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variable = 'batch_FcCh', 
    ylim.rle.plot = NULL, 
    iqr.width = 1, 
    median.points.size = 1, 
    median.points.color = 'cyan', 
    geom.hline.color = 'red', 
    plot.ncol = 1, 
    plot.nrow = 4, 
    plot.output = TRUE, 
    save.se.obj = TRUE, 
    verbose = TRUE)
```


```{r}
brca.se.obj <- plotRleVariable(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variable = 'tumour.purity.estimate', 
    rle.data.type = 'both', 
    ylim.rle.med.plot = NULL, 
    ylim.rle.iqr.plot = NULL, 
    points.size = 1, 
    plot.ncol = 2, 
    plot.nrow = 3, 
    plot.output = TRUE, 
    save.se.obj = TRUE, 
    verbose = TRUE)
brca.se.obj@metadata$metric$fpkm_unstrand$RLE$rle.data$rle.med
```


```{r}
brca.se.obj <- computePCA(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    fast.pca = TRUE, 
    nb.pcs = 10, 
    center = TRUE, 
    scale = FALSE, 
    apply.log = FALSE, 
    pseudo.count = 1, 
    svd.bsparam = BiocSingular::bsparam(), 
    assess.se.obj = FALSE, 
    remove.na = 'none', 
    save.se.obj = TRUE, 
    verbose = TRUE)
```

```{r}
brca.se.obj <- RUVIIIPRPS::plotPCA(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variable = 'paper_BRCA_Subtype_PAM50', 
    fast.pca = TRUE, 
    nb.pcs = 3,
    plot.type = 'scatter',
    points.size = 1, 
    stroke.color = 'gray', 
    stroke.size = .2, 
    points.alpha = .4, 
    densities.alpha = .3, 
    plot.ncol = 1, 
    plot.nrow = 3,
    save.se.obj = TRUE, 
    verbose = TRUE)
brca.se.obj@metadata$plot$PCA$fastPCA$paper_BRCA_Subtype_PAM50
```

```{r}
brca.se.obj <- computePCVariableCorrelation(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variable = 'batch_FcCh', 
    fast.pca = TRUE, 
    nb.pcs = 10, 
    save.se.obj = TRUE, 
    verbose = TRUE)
```

```{r}
brca.se.obj <- plotPCVariableCorrelation(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variable = 'batch_FcCh', 
    fast.pca = TRUE, 
    nb.pcs = 10, 
    plot.output = TRUE, 
    save.se.obj = TRUE, 
    verbose = TRUE)
brca.se.obj@metadata$plot$VecCorr$batch_FcCh
```

```{r}
brca.se.obj <- computePCVariableRegression(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variable = 'tumour.purity.estimate', 
    fast.pca = TRUE, 
    nb.pcs = 10, 
    save.se.obj = TRUE,
    verbose = TRUE)
```

```{r}
brca.se.obj <- plotPCVariableRegression(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variable = 'tumour.purity.estimate', 
    fast.pca = TRUE, 
    nb.pcs = 10, 
    save.se.obj = TRUE, 
    plot.output = TRUE, 
    verbose = TRUE)
```

```{r}
brca.se.obj <- computeARI(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variable = 'batch_FcCh', 
    fast.pca = TRUE,
    nb.pcs = 3, 
    clustering.method = 'hclust', 
    hclust.method = 'complete', 
    hclust.dist.measure = 'euclidian', 
    save.se.obj = TRUE, 
    verbose = TRUE)
```

```{r}
brca.se.obj <- plotARI(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variables = 'batch_FcCh', 
    ari.method = 'hclust.complete.euclidian', 
    plot.type = 'single.plot', 
    plot.output = TRUE, 
    save.se.obj = TRUE, 
    verbose = TRUE)
```

```{r}
brca.se.obj <- computeSilhouette(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variable = 'batch_FcCh', 
    dist.measure = 'euclidian', 
    fast.pca = TRUE, 
    nb.pcs = 3, 
    save.se.obj = TRUE, 
    verbose = TRUE)
```


```{r}
brca.se.obj <- plotSilhouette(
    se.obj = brca.se.obj, 
    assay.names = 'all',
    variables = 'batch_FcCh', 
    silhouette.method = 'sil.euclidian', 
    plot.type = 'single.plot', 
    plot.output = TRUE, 
    save.se.obj = TRUE, 
    verbose = TRUE)
```


```{r}
brca.se.obj <- computeGenesVariableCorrelation(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variable = 'tumour.purity.estimate',
    method = 'spearman', 
    a = 0.05, 
    rho = 0, 
    apply.log = TRUE, 
    pseudo.count = 1 , 
    plot.top.genes = FALSE, 
    nb.top.genes = NULL,
    apply.round = TRUE, 
    assess.se.obj = FALSE, 
    remove.na = 'none', 
    save.se.obj = TRUE, 
    verbose = TRUE)
```


```{r}
brca.se.obj <- plotGenesVariableCorrelation(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variable = 'tumour.purity.estimate', 
    correlation.method = 'gene.spearman.corr', 
    plot.output = TRUE, 
    save.se.obj = TRUE, 
    verbose = TRUE)
```


```{r}
brca.se.obj <- computeGenesVariableAnova(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variable = 'batch_FcCh', 
    method = 'aov', 
    apply.log = TRUE,
    pseudo.count = 1, 
    plot.top.genes = TRUE,
    nb.top.genes = 3, 
    apply.round = FALSE,
    assess.se.obj = FALSE, 
    remove.na = 'none', 
    save.se.obj = TRUE, 
    verbose = TRUE)
```

```{r}
brca.se.obj <- plotGenesVariableAnova(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variable = 'batch_FcCh', 
    anova.method = 'genes.aov.anova', 
    plot.output = TRUE, 
    save.se.obj = TRUE, 
    verbose = TRUE)
brca.se.obj@metadata$plot$GeneVarAnova$genes.aov.anova
```


```{r}
brca.se.obj <- computeDGE(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variable = 'batch_FcCh', 
    apply.log = FALSE,
    pseudo.count = 1, 
    assess.se.obj = FALSE, 
    remove.na = 'none', 
    save.se.obj = TRUE, 
    verbose = TRUE)
```

```{r}
brca.se.obj <- plotDGE(
    se.obj = brca.se.obj, 
    assay.names = 'all', 
    variable = 'batch_FcCh', 
    plot.ncol = 7, 
    plot.output = TRUE, 
    save.se.obj = TRUE, 
    verbose = FALSE)
ks.test(brca.se.obj@metadata$metric$`RUVIIIRPPS_K:15`$DGE$batch_FcCh$p.vals$`FcCh_A&FcCh_B`$pvalue>0.1, "punif")
ks.test(brca.se.obj@metadata$metric$Log_fpkm_unstrand$DGE$batch_FcCh$p.vals$`FcCh_A&FcCh_B`$pvalue>0.1, "punif")
```


```{r}
head(all.de.tests$Log_fpkm_unstrand)
breaks <- seq(0, 1, by = .1)
binned <- cut(
    all.de.tests$Log_fpkm_unstrand$`FcCh_A&FcCh_B.pvalue`, 
    breaks = breaks, 
    include.lowest = TRUE)
frequency <- table(binned)
```



# TCGA READ data ####
## Download the data using the TCGAbiolinks R package

```{r downloadingTheData, message=F, warning=F}
# tcga.read.ranseq.data <- TCGAbiolinks::GDCquery(
#     project = 'TCGA-READ',
#     data.category = 'Transcriptome Profiling',
#     data.type = 'Gene Expression Quantification'
# )
# TCGAbiolinks::GDCdownload(tcga.read.ranseq.data)
# exp.se.obj <- TCGAbiolinks::GDCprepare(query = tcga.read.ranseq.data)
# qs::qsave(x = exp.se.obj, file = 'TCGA_ReAdRNAseq_StarCounts38_TCGAbiolinks.021424.qs')
```

```{r message=FALSE, warning=F}
library(SummarizedExperiment)
library(RUVIIIPRPS)
# exp.se.obj <- qs::qread(
#     file = 'TCGA_BrCaRNAseq_StarCounts38_TCGAbiolinks.021424.qs'
#     )
path <- "/Users/molania.r/Documents/Scientific_files.files/CurrentProjects/Project13.3_Test_RUVIIIPRPS_Package/Test_RUVIIIPRPS_Functions/"
exp.se.obj <- qs::qread(paste0(path,'TCGA_ReAdRNAseq_StarCounts38_TCGAbiolinks.021424.qs'))
gene.annot <- rowData(x = exp.se.obj)
exp.se.obj <- exp.se.obj[ gene.annot$gene_type == 'protein_coding', ]
gene.annot <- rowData(x = exp.se.obj)
exp.se.obj <- exp.se.obj[!duplicated(gene.annot$gene_name), ]
row.names(exp.se.obj) <- rowData(x = exp.se.obj)$gene_name
```


```{r}
path <- '/Users/molania.r/Documents/Scientific_files.files/CurrentProjects/Project13.3_Test_RUVIIIPRPS_Package/Test_RUVIIIPRPS_Functions/Data/'
batch.info <- readxl::read_excel(
    path = paste0(path, '/41587_2022_1440_MOESM3_ESM.xlsx'), 
    sheet = 1, 
    skip = 1)
batch.info <- as.data.frame(batch.info)
index <- intersect(batch.info$Samples, colnames(exp.se.obj))
exp.se.obj <- exp.se.obj[ , index]
batch.info <- batch.info[batch.info$Samples %in% index, ]
exp.se.obj$batch.years <- batch.info$Year
exp.se.obj$batch.plates <- batch.info$Plates
```


```{r}
selected.assays <- c(
    'unstranded', 
    'tpm_unstrand', 
    'fpkm_unstrand', 
    'fpkm_uq_unstrand')
data.sets <- lapply(
    selected.assays, 
    function(x) assay(x = exp.se.obj, i = x))
names(data.sets) <- selected.assays
sample.annotation <- as.data.frame(colData(exp.se.obj))
gene.annot <- as.data.frame(rowData(exp.se.obj))
colnames(gene.annot)[7] <- 'hgnc_symbol'
```

# Create a SummarizedExperiment object
Here we use the createSeObj() function to generate SummarizedExperiment object from the TCGA BrCa datastes. We remove lowly expressed genes, estimate library size and tumor purity. 

```{r createSeObj, message=FALSE, warning=F}
read.se.obj <- createSeObj(
    data.sets = data.sets, 
    raw.count.assay.name = 'unstranded', 
    gene.annotation = gene.annot,
    create.sample.annotation = FALSE,
    sample.annotation = sample.annotation,
    remove.lowly.expressed.genes = TRUE, 
    assay.name.to.estimate.purity = 'unstranded',
    estimate.tumor.purity = 'both',
    calculate.library.size = TRUE,
    add.housekeeping.genes = TRUE,
    add.immun.stroma.genes = TRUE,
    gene.group = 'hgnc_symbol'
    )
plot(read.se.obj$tumour.purity.singscore, read.se.obj$tumour.purity.estimate)
```



# Variation assessment
We select the 'paper_BRCA_Subtype_PAM50' as a biological variation and the 'library.size', 'tumour.purity' and 
'batch_FcCh' as sources of unwanted variation.

In this section we will assess the variation of different biological and unwanted variables using a range of metrics.
Before applying the metrics, we will assess the structure and missing values in the SummarizedExperiment object.


```{r}
read.se.obj$pu <- kmeans(x = read.se.obj$tumour.purity.estimate, centers = 3)$cluster
read.se.obj <- RUVIIIPRPS::identifyUnknownUV(
    se.obj = read.se.obj, 
    assay.name = 'unstranded', 
    regress.out.bio.variables = 'batch.plates',
    clustering.methods = 'kmeans',
    approach = 'rle', 
    max.samples.per.batch = .5, 
    nb.pcs = 1,
    nb.clusters = 3)
heatmap(table(paste0(read.se.obj$pu),
      read.se.obj@metadata$UknownUV$unstranded$pca_onAllGenes_kmeansClustering$batches))

plot(read.se.obj@metadata$UknownUV$unstranded$rle.median_onAllGenes_kmeansClustering$input.data, 
     read.se.obj$tumour.purity.estimate,
     col = factor(read.se.obj@metadata$UknownUV$unstranded$rle.median_onAllGenes_kmeansClustering$batches))


plot(read.se.obj@metadata$UknownUV$unstranded$pca_onAllGenes_kmeansClustering$input.data[,2], read.se.obj$tumour.purity.estimate)
mm <- brca.se.obj@metadata$UknownUV$unstranded$rlemedianonAllGenes_kmeansClustering$batches
table(mm)
table(mm, brca.se.obj$batch.FcCh)

plot(brca.se.obj@metadata$SourcesOfUV$unstranded$Unknown$rlemedianonAllGenes_kmeansClustering$input.data, 
     col = factor(brca.se.obj@metadata$SourcesOfUV$unstranded$Unknown$rlemedianonAllGenes_kmeansClustering$batches) )

```
