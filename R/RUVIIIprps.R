#' The RUV-III method with technical replicates or PRPS normalization.

#' @author Ramyar Molania

#' @description
#' This function applies the RUV-III with technical replicates or PRPS on transcriptions data.

#' @details
#' RUV-III normalization. Before we can describe the linear model underlying RUV-III, we need to introduce the m × m1
#' mapping matrix M connecting assays to distinct samples, which captures the pattern of replication in our assays. Here,
#' m is the number of assays, and m1 is the number of distinct samples being assayed. M(i,h) = 1if assay i is on sample
#' h and M(i,h) = 0 otherwise. Each row of M sums to 1, and the columns sum to the distinct sample replication numbers, the
#' elements of MTM. We also define an m1 × p design matrix X to capture the biological factor(s) of interest indexed by
#' sample rather than assay. There are no constraints on p; indeed, X could be the m1 × m1 identity matrix. Our goal
#' here is to remove unwanted variation, not to estimate regression parameters.
#' The linear model we use is: Y = 1μ + MXβ + Wα + ε
#' where the data Y = (yij)and unobserved errors ε = (εij)are m × n; the matrices X and M have just been defined; μ is
#' the 1 × n row of gene means; β is p × n; the matrix W whose columns capture the unwanted variation is m × k; and α
#' is k × n. 1 = 1m is the m × 1 column vector of 1s. Here, m = number of assays, n = number of genes and p is the
#' dimension of the wanted variation X and k that of the unwanted variation W. Assume that W⊥1. Also, we suppose that we
#' have a subset of nc of negative control genes whose m × nc submatrix Yc satisfies Yc = 1μc + Wαc + εc, where we have
#' assumed that βc = 0—that is, that there is no true association between these genes and the biology of interest.
#' The projection PM = M(M M) M replaces each entry yij of Y by the simple average of the entries yi′j over all i′ for
#' which M (i, h) = M (i′ , h) = 1—that is, over all i′ such that i′ and i label replicate assays of the same unique
#' sample (or pseudo-sample) labeled h. Write RM = I − PM for the corresponding residual projector. This is our source
#' of information on the unwanted variation that we will remove. If the replication is technical at some level, then RMY
#' mainly contains information about unwanted variation in the system after the technical replicates were created.
#' Depending on the study details, technical replicates could be created immediately beforethe assay was run, in parallel
#' with or immediately after sample was collected or somewhere in between. The earlier the creation of technical replicates,
#' the more unwanted variation will be captured in their differences. The use of pseudo-replicates of suitable pseudo-samples
#' enables us to start to deal with pre-technical unwanted variation. Write the spectral decomposition of RMYY RM = UDU ,
#' where U is an m × m orthogonal matrix and D is an m × n diagonal matrix with entries ordered from largest to smallest
#' eigenvalue. Let P1 be the orthogonal projection onto 1m. For a chosen k, 1 ≤ k ≤ m−m1,
#' I- Define αˆ(k) = U(k)TY, where U(k) is the first k columns of U
#' II- Estimate W by regressing the centered negative controls (I − P1)Yc on αˆ(k)T c
#' III-


#' @references
#' * Molania R., ..., Speed, T. P., A new normalization for Nanostring nCounter gene expression data, Nucleic Acids Research,
#' 2019.
#' * Molania R., ..., Speed, T. P., Removing unwanted variation from large-scale RNA sequencing data with PRPS,
#' Nature Biotechnology, 2023


#' @param se.obj A SummarizedExperiment object.
#' @param assay.name Symbol. A symbol indicating the name of the assay in the SummarizedExperiment object. The selected
#' assay should be the one that has been used for PRPS and NCGs selection.
#' @param prps.type Symbol. A symbol denoting which groups of the generated PRPS should be utilized for normalization. The
#' options include 'supervised,' 'unsupervised,' or 'both.' When 'supervised' is chosen, the function employs the PRPS
#' set(s) generated through supervised functions. Opting for 'unsupervised' utilizes the PRPS set(s) created through
#' unsupervised functions. If 'both' is selected, the function utilizes the PRPS set(s) generated by both supervised and
#' unsupervised functions. The default setting is 'supervised.'
#' @param prps.group Symbol. A symbol indicating the name of PRPS group under the 'prps.type' slot.
#' @param prps.set.names A symbol specifying th exact name of a PPRS set under the 'prps.group' name in the supervised or
#' un.supervised slots in the SummarizedExperiment object. The default is set to 'all'. This will select all available
#' PRPS sets for the specified 'prps.group'.
#' @param ncg.type Symbol. A symbol indicating which groups of the computed NCGs should be utilized for normalization. The
#' options include 'supervised,' 'unsupervised,' or 'both.' When 'supervised' is chosen, the function employs the PRPS
#' set(s) generated through supervised functions. Opting for 'unsupervised' utilizes the PRPS set(s) created through
#' unsupervised functions. If 'both' is selected, the function utilizes the PRPS set(s) generated by both supervised and
#' unsupervised functions. The default setting is 'supervised.'
#' @param ncg.group Symbol. A symbol indicating the name of NCGs group under the 'prps.type' slot.
#' @param ncg.set.names A symbol specifying th exact name of a NCG set under the 'ncg.group' name in the 'supervised' or
#' 'un.supervised' slots in the SummarizedExperiment object. The default is set to 'all'. This will select all available
#' NCG sets for the specified 'ncg.group'.
#' @param technical.replicates Vector. A vector of sample names that contain at least a technical duplicate. The length of
#' vector must as similar to the number of sample in the SummarizedExperiment object. The sample names of each set of
#' technical replicate must be the same. See the details for more information.
#' @param k Numeric. A numeric value or a vector of numeric values indicating the number of unwanted factors to be calculated
#' and used to remove unwanted variation from the data. If a vector is provided, the function applies the RUV-III method
#' for each individual value, up to a maximum of possible k values for each normalization. See the details for more information.
#' @param apply.log Logical. Indicates whether to apply a log-transformation to the data or PRPS or both. The default it
#' is set to 'TRUE'.
#' @param data.to.log Symbol. A symbol specifying the data that must be logged transformed before applying the RUV-III
#' method.  The options are 'assay', 'prps' , 'both' or 'non'. Remember, both data and PRPS must be in log scale before
#' applying the RUV-III data.
#' @param pseudo.count Numeric. A numeric value as a pseudo count to be added to all measurements before log transformation.
#' The default it is set to 1. Note, the current RUV-III method does not support NA or missing values.
#' @param eta Symbol. Gene-wise (as opposed to sample-wise) covariates. These covariates are adjusted for by RUV-1 before any
#' further analysis proceeds. Can be either (1) a matrix with n columns, (2) a matrix with n rows, (3) a dataframe with
#' n rows, (4) a vector or factor of length n, or (5) simply 1, for an intercept term.
#' @param include.intercept When eta is specified (not NULL) but does not already include an intercept term, this will
#' automatically include one.
#' @param return.info If 'TRUE', additional information including the W matrix of the RUV-III method is returned. The
#' default is set to 'TRUE'.
#' @param assess.se.obj Logical. Indicates whether to assess the SummarizedExperiment object or not. The default is set
#' to 'TRUE'. Refer to the checkSeObj function for more details.
#' @param remove.na Symbol. A symbol indicating to remove NA or missing values from the assays or not. The options are
#' 'assays' and 'none'. The default is "assays", so all the NA or missing values from the assay(s) will be removed before
#' applying the RUV-III method. See the 'checkSeObj' function for more details.
#' @param output.name Symbol. A Symbol to use for the name(s) of the RUV-III normalized datasets. The default is set to
#' 'NULL', them individual RUV-III normalized data will be named as follow
#' paste0('RUVIIIPRPS_K_', k.vals)
#' @param save.se.obj Logical. Indicates whether to save the RUV-III-PRPS normalized data as new assay(s) in the
#' SummarizedExperiment object or to output them as list. The default it is set to 'TRUE'.
#' @param verbose Logical. If 'TRUE', shows the messages of different steps of the function.

#' @return Either the SummarizedExperiment object containing the RUV-III normalized gene expression data as new assay(s)
#' or a list of the RUV-III normalized gene expression data set(s).

#' @importFrom SummarizedExperiment SummarizedExperiment assay colData
#' @importFrom ruv replicate.matrix RUV1
#' @importFrom BiocSingular bsparam
#' @importFrom Matrix solve
#' @export

RUVIIIprps <- function(
        se.obj,
        assay.name,
        prps.type = 'supervised',
        prps.group,
        prps.set.names = NULL,
        ncg.type = 'supervised',
        ncg.group,
        ncg.set.names = NULL,
        technical.replicates = NULL,
        k = 1,
        apply.log = TRUE,
        data.to.log = 'assay',
        pseudo.count = 1,
        eta = NULL,
        include.intercept = TRUE,
        return.info = FALSE,
        assess.se.obj = TRUE,
        remove.na = 'none',
        output.name = NULL,
        save.se.obj = TRUE,
        verbose = TRUE
        ) {
    printColoredMessage(message = '------------The RUVIII.PRPS function starts:',
                        color = 'white',
                        verbose = verbose)
    # Check inputs ####
    if(!is.vector(assay.name) | length(assay.name) > 1 | is.logical(assay.name) | assay.name == 'all'){
        stop('The "assay.name" must be the name of an assay in the SummarizedExperiment object.')
    }
    if(!assay.name %in% names(assays(se.obj))){
        stop('The "assay.name" cannot be found in the SummarizedExperiment object.')
    }
    if(!prps.type %in% c('supervised', 'un.supervised', 'both', 'none')){
        stop('The "prps.type" must be of the "supervised", "un.supervised", "both" or "none".')
    }
    if(prps.type != 'none'){
        if(length(se.obj@metadata) == 0 | !'PRPS' %in% names(se.obj@metadata)){
            stop('Any PRPS data cannot be found in the SummarizedExperiment object.')
        }
        if(is.null(prps.type) | is.logical(prps.type)){
            stop('The "prps.type" cannot be NULL or logical.')
        }
        if(prps.type == 'supervised'){
            if(!'supervised' %in% names(se.obj@metadata$PRPS)){
                stop('The "supervised" object does not exist in the PRPS slot of the metada of the SummarizedExperiment object.')
            }
            if(length(se.obj@metadata$PRPS$supervised) == 0){
                stop('The "supervised" object in the PRPS slot of the metada of the SummarizedExperiment object does not have any data.')
            }
            if(sum(prps.group %in% names(se.obj@metadata$PRPS$supervised)) != length(prps.group)){
                stop('The "prps.group" cannot be found in the "supervised" part of th PRPS slot in the the metada.')
            }
            if(!is.null(prps.set.names)){
                if(sum(prps.set.names %in% names(se.obj@metadata$PRPS$un.supervised[[prps.group]]$prps.data)) != length(prps.set.names)){
                    stop('All or some of the "prps.set.names" cannot be found in the "supervised" part of th PRPS slot in the the metada.')
                }
            }
        }
        if(prps.type == 'un.supervised'){
            if(!'un.supervised' %in% names(se.obj@metadata$PRPS)){
                stop('The "un.supervised" object does not exist in the PRPS slot of the metada of the SummarizedExperiment object.')
            }
            if(length(se.obj@metadata$PRPS$un.supervised) == 0){
                stop('The "un.supervised" object in the PRPS slot of the metada of the SummarizedExperiment object does not have any data.')
            }
            if(sum(prps.group %in% names(se.obj@metadata$PRPS$un.supervised)) != length(prps.group) ){
                stop('The "prps.group" cannot be found in the "un.supervised" part of th PRPS slot in the the metada.')
            }
            if(!is.null(prps.set.names)){
                if(sum(prps.set.names %in% names(se.obj@metadata$PRPS$un.supervised[[prps.group]]$prps.data) ) != length(prps.set.names) ){
                    stop('All or some of the "prps.set.names" cannot be found in the "un.supervised" part of th PRPS slot in the the metada.')
                }
            }
        }
        if (prps.type == 'both'){
            if(!'supervised' %in% names(se.obj@metadata$PRPS)){
                stop('The "supervised" object does not exist in the PRPS slot of the metada of the SummarizedExperiment object.')
            }
            if(length(se.obj@metadata$PRPS$supervised) == 0){
                stop('The "supervised" object in the PRPS slot of the metada of the SummarizedExperiment object does not have any data.')
            }
            if(!'un.supervised' %in% names(se.obj@metadata$PRPS)){
                stop('The "un.supervised" object does not exist in the PRPS slot of the metada of the SummarizedExperiment object.')
            }
            if(length(se.obj@metadata$PRPS$un.supervised) == 0){
                stop('The "un.supervised" object in the PRPS slot of the metada of the SummarizedExperiment object does not have any data.')
            }
            all.prps.group <- c(names(se.obj@metadata$PRPS$supervised), names(se.obj@metadata$PRPS$un.supervised))
            if(sum(prps.group %in% all.prps.group) != length(prps.group)){
                stop('The "prps.group" cannot be found in either "supervised" or "un.supervised" parts of th PRPS slot in the the metada.')
            }
            if(!is.null(prps.set.names)){
                supervised.prps.group <- all.prps.group[all.prps.group %in% names(se.obj@metadata$PRPS$supervised)]
                un.supervised.prps.group <- all.prps.group[all.prps.group %in% names(se.obj@metadata$PRPS$un.supervised)]
                all.prps.set.names <- c(
                    names(se.obj@metadata$PRPS$supervised[[supervised.prps.group]]$prps.data),
                    names(se.obj@metadata$PRPS$un.supervised[[un.supervised.prps.group]]$prps.data)
                )
                if(sum(prps.set.names %in% all.prps.set.names) != length(prps.set.names)){
                    stop('All or some of the "prps.set.names" cannot be found in the "supervised" or "un.supervised" parts of th PRPS slot in the the metada.')
                }
            }
            }
    }
    if(!ncg.type %in% c('supervised', 'un.supervised', 'pre.selected', 'all.genes')){
        stop('The "ncg.type" must be of the "supervised", "un.supervised", "pre.selected" or "all.genes".')
    }
    if(ncg.type != 'all.genes'){
        if(!'NCG' %in% names(se.obj@metadata)){
            stop('The "NCG" object does not exist in the metada of the SummarizedExperiment object.')
        }
        if(ncg.type == 'supervised'){
            if(!'supervised' %in% names(se.obj@metadata$NCG)){
                stop('The supervised "NCG" object does not exist in the NCG slot of the metada of the SummarizedExperiment object.')
            }
            if(!ncg.group %in% names(se.obj@metadata$NCG$supervised)) {
                stop('The ncg.group object does not exist in the NCG slot of the metada of the SummarizedExperiment object.')
            }
            if(!is.null(ncg.set.names)){
                if(sum(ncg.set.names %in% names(se.obj@metadata$NCG$supervised[[ncg.group]]$ncg.set)) != length(ncg.set.names)){
                    stop('All or some of "ncg.set.names" cannot be found in the SummarizedExperiment object.')
                }
            }
        }
        if(ncg.type == 'un.supervised'){
            if(!'un.supervised' %in% names(se.obj@metadata$NCG)){
                stop('The un.supervised "NCG" object does not exist in the NCG slot of the metada of the SummarizedExperiment object.')
            }
            if(!ncg.group %in% names(se.obj@metadata$NCG$un.supervised)){
                stop('The ncg.group object does not exist in the NCG slot of the metada of the SummarizedExperiment object.')
            }
            if(!is.null(ncg.set.names)){
                if(sum(ncg.set.names %in% names(se.obj@metadata$NCG$un.supervised[[ncg.group]])) != length(ncg.set.names)){
                    stop('All or some of "ncg.set.names" cannot be found in the SummarizedExperiment object.')
                }
            }
        }
        if(ncg.type == 'pre.selected'){
            if(!'pre.selected' %in% names(se.obj@metadata$NCG)){
                stop('"pre.selected" NCG data canot be found in the metadata of the SummarizedExperiment object.')
            }
            if(sum(ncg.group %in% names(se.obj@metadata$NCG$pre.selected)) != length(ncg.group)){
                stop('All or some of "ncg.group" cannot be found in the SummarizedExperiment object.')
            }
        }
    }

    if(prps.type == 'none' & is.null(technical.replicates)){
        stop('To run RUVIII either the "prps.type" or "technical.replicates" or both must be specified.')
    }
    if(!is.null(technical.replicates)){
        if(length(technical.replicates) != ncol(se.obj)){
            stop('The length of the "technical.replicate" must be the same as the length of the column name of the the SummarizedExperiment object.')
        }
    }
    if (min(k) <= 0){
        stop('k cannot be 0 or negative values.')
    }
    if(!data.to.log %in% c("assay", "prps", "both")){
        stop('The "data.to.log" must be one of the "assay", "prps" or "both".')
    }

    # Assess the SummarizedExperiment object ####
    if (isTRUE(assess.se.obj)) {
        se.obj <- checkSeObj(
            se.obj = se.obj,
            assay.names = assay.name,
            variables = NULL,
            remove.na = remove.na,
            verbose = verbose)
    }

    # Obtain control assays ####
    ## technical replicates ####
    if(!is.null(technical.replicates)){
        printColoredMessage(
            message = '-- Obtain technical replicates data:',
            color = 'magenta',
            verbose = verbose
            )
        rep.samples <- findRepeatingPatterns(
            vec = technical.replicates,
            n.repeat = 2
            )
        if(length(rep.samples) == 0){
            stop('All the sample names of the "technical.replicates" are unique. Individual technical replicate sets must have the same names.')
        } else {
            printColoredMessage(
                message = paste0(
                    'There is(are) ', length(unique(rep.samples)), ' sets of technical replicates in the data.'),
                color = 'blue',
                verbose = verbose
                )
        }
        colnames(se.obj) <- technical.replicates
    }
    ## prps ####
    if(prps.type != 'none'){
        ### obtain PRPS data ####
        printColoredMessage(
            message = '-- Obtain the PRPS data in the SummarizedExperiment object:',
            color = 'magenta',
            verbose = verbose
        )
        ### supervised ####
        if(prps.type == 'supervised'){
            printColoredMessage(
                message = paste0(
                    '- The prps group "',
                    prps.group,
                    '" has ',
                    length(se.obj@metadata$PRPS$supervised[[prps.group]]$prps.data),
                    ' PRPS sub_group(s).'),
                color = 'blue',
                verbose = verbose
            )
            if(!is.null(prps.set.names)){
                prps.data <- lapply(
                    prps.set.names,
                    function(x) {
                        se.obj@metadata$PRPS$supervised[[prps.group]]$prps.data[[x]]
                    })
                names(prps.data) <- prps.set.names
            }
            if(is.null(prps.set.names)){
                prps.set.names <- names(se.obj@metadata$PRPS$supervised[[prps.group]]$prps.data)
                prps.data <- lapply(
                    prps.set.names,
                    function(x) {
                        se.obj@metadata$PRPS$supervised[[prps.group]]$prps.data[[x]]
                    })
                names(prps.data) <- prps.set.names
            }
        }
        ### un supervised ####
        if (prps.type == 'un.supervised'){
            printColoredMessage(
                message = paste0(
                    '- The prps group "',
                    prps.group,
                    '" has ',
                    length(se.obj@metadata$PRPS$un.supervised[[prps.group]]$prps.data),
                    ' PRPS sub_group(s).'),
                color = 'blue',
                verbose = verbose
            )
            if(!is.null(prps.set.names)){
                prps.data <- lapply(
                    prps.set.names,
                    function(x) {
                        se.obj@metadata$PRPS$un.supervised[[prps.group]]$prps.data[[x]]
                    })
                names(prps.data) <- prps.set.names
            }
            if(is.null(prps.set.names)){
                prps.set.names <- names(se.obj@metadata$PRPS$un.supervised[[prps.group]]$prps.data)
                prps.data <- lapply(
                    prps.set.names,
                    function(x) {
                        se.obj@metadata$PRPS$un.supervised[[prps.group]]$prps.data[[x]]
                    })
                names(prps.data) <- prps.set.names
            }
        }
        ### both ####
        if (prps.type == 'both'){
            if(is.null(prps.group)){
                prps.data <- c(
                    se.obj@metadata$PRPS$supervised,
                    se.obj@metadata$PRPS$un.supervised$prps.data
                )
            } else{
                prps.data.sup <- lapply(
                    prps.group,
                    function(x) se.obj@metadata$PRPS$supervised[[x]])
                names(prps.data.sup) <- prps.group
                prps.data.unsup <- lapply(
                    prps.group,
                    function(x) se.obj@metadata$PRPS$un.supervised[[x]])
                names(prps.data.unsup) <- prps.group
                prps.data <- c(prps.data.sup, prps.data.unsup)
                prps.data <- Filter(Negate(is.null), prps.data)
            }
            printColoredMessage(
                message = paste0(
                    length(prps.data),
                    ' supervised/unsupervised PRPS set(s) are found in the SummarizedExperiment object.'),
                color = 'blue',
                verbose = verbose
                )
        }
        ### check dimension and gene names in the prps data ####
        printColoredMessage(
            message = '- Check row names and number of pseudo samples in the PRPS data:',
            color = 'orange',
            verbose = verbose
            )
        check.prps.data <- lapply(
            1:length(prps.data),
            function(x){
                if (nrow(se.obj) != nrow(prps.data[[x]]) ) {
                    stop('The number of genes between the SummarizedExperiment object and the prps data is not the same.')
                }
                if (isFALSE(all.equal(row.names(se.obj), row.names(prps.data[[x]]))) ) {
                    stop('The order of genes are not the same between the SummarizedExperiment object and the PRPS data.')
                }
                rep.samples <- findRepeatingPatterns(
                    vec = colnames(prps.data[[x]]),
                    n.repeat = 2
                )
                if (length(rep.samples) == 0) {
                    stop('The names of the columns in the "prps.data" are all unique.')
                } else if (isTRUE(length(rep.samples) != length(unique(colnames(prps.data[[x]]))))) {
                    stop('Some names of the columns in the "prps.data" are all unique.')
                }
            })
        printColoredMessage(
            message = '- The PRPS data has no issues.',
            color = 'blue',
            verbose = verbose
        )
        ### merge all the PRPS data ####
        printColoredMessage(
            message = '- Merge all the PPRS data:',
            color = 'orange',
            verbose = verbose
        )
        prps.data <- do.call(cbind, prps.data)
        printColoredMessage(
            message = '- The final PRPS data has:',
            color = 'blue',
            verbose = verbose
        )
        printColoredMessage(
            message = paste0('* ', ncol(prps.data), ' pseudo-samples'),
            color = 'blue',
            verbose = verbose
        )
        printColoredMessage(
            message = paste0('* ', length(findRepeatingPatterns(vec = colnames(prps.data), n.repeat = 2)), ' PRPS sets.'),
            color = 'blue',
            verbose = verbose
        )
    } else prps.data <- NULL

    # Control genes ####
    if(isTRUE(ncg.type != 'all.genes')){
        ## obtain NCG ####
        printColoredMessage(
            message = '-- Obtain the selected NCGs in the SummarizedExperiment object',
            color = 'magenta',
            verbose = verbose
        )
        ## supervised ####
        if(ncg.type == 'supervised'){
            if(is.null(ncg.set.names)){
                printColoredMessage(
                    message = paste0('- The supervised NCG group "', ncg.group, '" has ',
                                     length(se.obj@metadata$NCG$supervised[[ncg.group]]$ncg.set),
                                     ' NCG sub_group(s).'),
                    color = 'blue',
                    verbose = verbose
                )
                if(length(se.obj@metadata$NCG$supervised[[ncg.group]]$ncg.set) > 1){
                    printColoredMessage(
                        message = '- The union of the NCGs sets will be used.',
                        color = 'blue',
                        verbose = verbose
                    )
                }
                ncg <- se.obj@metadata$NCG$supervised[[ncg.group]]$ncg.set
            }
            if(!is.null(ncg.set.names)){
                ncg <- lapply(
                    ncg.set.names,
                    function(x) se.obj@metadata$NCG$supervised[[ncg.group]]$ncg.set[[x]]
                    )
                if(length(ncg.set.names) > 1){
                    printColoredMessage(
                        message = '- The union of the NCGs sets will be used.',
                        color = 'blue',
                        verbose = verbose
                    )
                }
                names(ncg) <- ncg.set.names
            }
        }

        ## un supervised ####
        if (ncg.type == 'un.supervised'){
            if(is.null(ncg.set.names)){
                printColoredMessage(
                    message = paste0('- The un.supervised NCG group "', prps.group, '" has ',
                                     length(se.obj@metadata$NCG$un.supervised[[ncg.group]]$ncg.set),
                                     ' PRPS sub_group(s).'),
                    color = 'blue',
                    verbose = verbose
                )
                if(length(se.obj@metadata$NCG$un.supervised[[ncg.group]]$ncg.set) > 1){
                    printColoredMessage(
                        message = '- The union of the NCGs sets will be used.',
                        color = 'blue',
                        verbose = verbose
                    )
                }
                ncg <- se.obj@metadata$NCG$un.supervised[[ncg.group]]$ncg.set
            }
            if(!is.null(ncg.set.names)){
                ncg <- lapply(
                    ncg.set.names,
                    function(x) se.obj@metadata$NCG$un.supervised[[ncg.group]]$ncg.set[[x]])
                if(length(ncg.set.names) > 1){
                    printColoredMessage(
                        message = '- The union of the NCGs sets will be used.',
                        color = 'blue',
                        verbose = verbose
                    )
                }
                names(ncg) <- ncg.set.names
            }
        }
        ## pre selected ####
        if (ncg.type == 'pre.selected'){
            if(is.null(ncg.group)){
                ncg <- se.obj@metadata$NCG$pre.selected
            } else{
                ncg <- lapply(
                    ncg.group,
                    function(x) se.obj@metadata$NCG$pre.selected[[x]])
                names(ncg) <- ncg.group
            }
            printColoredMessage(
                message = paste0(length(ncg), ' supervised NCG set(s) are found in the SummarizedExperiment object.'),
                color = 'blue',
                verbose = verbose)
        }

    } else if (ncg.type == 'all.genes') {
        ncg <- list(all.genes = row.names(se.obj) %in% row.names(se.obj))
    }
    ncg <- do.call(cbind, ncg)
    ncg <- rowSums(ncg) != 0
    printColoredMessage(
        message = paste0('- The final set of NCGs contains ', sum(ncg),  ' genes.'),
        color = 'blue',
        verbose = verbose
    )

    # Check max k for each normalization ####
    printColoredMessage(
        message = '-- Check max k for each normalization:',
        color = 'magenta',
        verbose = verbose
    )
    control.assay <- findRepeatingPatterns(
        vec = c(colnames(prps.data), colnames(se.obj)),
        n.repeat = 2
        )
    max.k.values <- min(length(control.assay), sum(ncg))
    printColoredMessage(
        message = paste0('- The maximum k for the curret control assays and NCGs is ', max.k.values, '.'),
        color = 'blue',
        verbose = verbose
        )

    # Find possible runs of RUV-III ####
    printColoredMessage(
        message = '-- Possible runs of RUV-III based on the current parameters:',
        color = 'magenta',
        verbose = verbose
        )
    if(isTRUE(length(k) == 1)){
        if(max.k.values >= k){
            printColoredMessage(
                message = paste0('- The RUV-III will be performed with k = ', k, '.'),
                color = 'blue',
                verbose = verbose
                )
        } else if( k > max.k.values ){
            printColoredMessage(
                message = '- Please note that the specified k value(s) exceeds the maximum allowable k value for the current PRPS data and NCGs',
                color = 'red',
                verbose = verbose
                )
            printColoredMessage(
                message = paste0('- The RUV-III will be performed with k = ', max.k.values, '.'),
                color = 'blue',
                verbose = verbose
                )
            k <- max.k.values
        }
    } else if (isTRUE(length(k) > 1)){
        if( max.k.values >= max(k) ){
            printColoredMessage(
                message = paste0('- The RUV-III will be performed with k = ', paste0(k, collapse = ','), '.'),
                color = 'blue',
                verbose = verbose
                )
        } else if ( max(k) >  max.k.values){
            printColoredMessage(
                message = 'Please note, the maximum of specifed k values is greate than possible maximum k for the curret PRPS data and NCGs',
                color = 'red',
                verbose = verbose
                )
        }
        k <- k[ k <= max.k.values]
        printColoredMessage(
            message = paste0('- The RUV-III will be performed with k = ', paste0(k, collapse = ','), '.'),
            color = 'blue',
            verbose = verbose
            )
    }
    printColoredMessage(
        message = paste0('- In totall ', length(k), ' runs of RUV-III-PRPS will applied.'),
        color = 'blue',
        verbose = verbose)

    # Apply data transformation ####
    if(isTRUE(apply.log)){
        if (is.null(pseudo.count)) pseudo.count = 0
        printColoredMessage(
            message = '-- Data log transformation:',
            color = 'magenta',
            verbose = verbose
        )
        printColoredMessage(
            message = 'Note, make sure both the assay and PRPS data are log transformed.',
            color = 'red',
            verbose = verbose
        )
        if (data.to.log == 'both') {
            printColoredMessage(
                message = paste('Apply log2 + ', pseudo.count, ' (pseudo.count) on both assay and prps data.'),
                color = 'blue',
                verbose = verbose
            )
            Y <- log2(assay(se.obj, assay.name) + pseudo.count)
            prps.data <- log2(prps.data + pseudo.count)
        } else if (data.to.log == 'assay') {
            printColoredMessage(
                message = paste0('Apply log2 + ', pseudo.count, ' (pseudo.count) on only assay.'),
                color = 'blue',
                verbose = verbose
            )
            Y <- log2(assay(se.obj, assay.name) + pseudo.count)
        } else if (data.to.log == 'prps') {
            printColoredMessage(
                message = paste('Apply log2 + ', pseudo.count, ' (pseudo.count) on only assay.'),
                color = 'blue',
                verbose = verbose
            )
            prps.data <- log2(prps.data + pseudo.count)
        }
    } else if (isFALSE(apply.log)) {
        printColoredMessage(
            message = 'It seems both assay and PRPS are already log transformed.',
            color = 'blue',
            verbose = verbose
        )
        Y <- assay(x = se.obj, i = assay.name)
    }

    # RUVIII normalization ####
    printColoredMessage(
        message = '-- Apply the RUV-III method:',
        color = 'magenta',
        verbose = verbose
        )
    ## k > 1 ####
    if (length(k) > 1) {
        printColoredMessage(
            message = '- The length of k is more than 1. Then,  alpha will be calculated for the maximum value of k.',
            color = 'blue',
            verbose = verbose
        )
        printColoredMessage(
            message = '- Appky RUV-III for the maximum value of k.',
            color = 'orange',
            verbose = verbose
            )
        ### check ncg ####
        ncg.set <- ncg
        ncg.logi <- rep(FALSE, nrow(se.obj))
        ncg.logi[ncg.set] <- TRUE
        ncg.set <- ncg.logi
        ## check prps data ####
        prps.data <- prps.data
        k.vals <- k
        ## merge Y and PRPS ####
        Y <- t(cbind(Y, prps.data))
        if (is.data.frame(Y))
            Y <- data.matrix(Y)
        if (sum(is.na(Y)) > 0) {
            stop("The assay or PRPS data contains missing values. This is not supported.")
        } else if (sum(Y == Inf, na.rm = TRUE) + sum(Y == -Inf, na.rm = TRUE) > 0) {
            stop("The assay or PRPS data contains infinity values. This is not supported.")
        }
        ##  apply RUV1 on Y ####
        printColoredMessage(
            message = '* apply RUV1 on the both assay and prps data:',
            color = 'blue',
            verbose = verbose
            )
        Y <- ruv::RUV1(
            Y = Y,
            eta = eta,
            ctl = ncg.set,
            include.intercept = include.intercept
            )
        ## data standardization ####
        printColoredMessage(
            message = '* standardize the data.',
            color = 'blue',
            verbose = verbose
            )
        Y.stand <- scale(Y, center = TRUE, scale = FALSE)

        ## create M matrix ####
        printColoredMessage(
            message = '* create M martix.',
            color = 'blue',
            verbose = verbose
            )
        M <- replicate.matrix(row.names(Y))
        printColoredMessage(
            message = paste0('** The M martix has ', nrow( M), ' rows and ', ncol(M), ' columns'),
            color = 'blue',
            verbose = verbose
            )

        ## sanity check on the M matrix ####
        printColoredMessage(
            message = '* sanity check on the M matrix.',
            color = 'blue',
            verbose = verbose
            )
        sum(rowSums(M) != 1)
        sum(colSums(M) == 1)
        if(nrow(M) == ncol(M)){
            stop('The columns and rows of the M matrix are the same, this is an issue.')
        }

        ## obtain residuals from the control assays ####
        printColoredMessage(
            message = '* obtain residuals from the control assays.',
            color = 'blue',
            verbose = verbose
            )
        Y0 <- fastResidop2(Y, M)
        # Y0 <- optimized_function(Y, M)
        ## apply svd on the residuals and the obtain alpha ####
        printColoredMessage(
            message = '* apply svd on the residuals to obtain alpha.',
            color = 'blue',
            verbose = verbose
            )
        set.seed(22331)
        left.sing.value <- BiocSingular::runSVD(
            x = Y0,
            k = max(k.vals),
            BSPARAM = bsparam(),
            center = TRUE,
            scale = FALSE
            )$u
        alpha <- t(left.sing.value[, 1:max(k.vals), drop = FALSE]) %*% Y
        ac <- alpha[, ncg.set, drop = FALSE]
        ## obtain W ####
        printColoredMessage(
            message = '* obtain W.',
            color = 'blue',
            verbose = verbose
            )
        W <- Y.stand[, ncg.set] %*% t(ac) %*% solve(ac %*% t(ac))
        ## obtain normalized data for the maximum value of k ####
        printColoredMessage(
            message = '* obtain the normalized data for the maximum value of k:',
            color = 'blue',
            verbose = verbose
            )
        newY.max <- Y - W %*% alpha
        newY.max <- t(newY.max[1:ncol(se.obj) ,])
        newY.max <- list(newY = newY.max, W = W[1:ncol(se.obj) , , drop = FALSE])
        ## obtain normalized data for other values of k ####
        other.k <- k.vals[!k.vals %in% max(k.vals)]
        printColoredMessage(
            message = '* obtain the normalized data for the values of k:',
            color = 'blue',
            verbose = verbose
            )
        all.ruv <- lapply(
            other.k,
            function(y) {
                alpha <- t(left.sing.value[ , 1:y, drop = FALSE]) %*% Y
                ac <- alpha[, ncg.set, drop = FALSE]
                W <- Y.stand[, ncg.set] %*% t(ac) %*% solve(ac %*% t(ac))
                newY <- Y - W %*% alpha
                newY <- t(newY[1:ncol(se.obj) , ])
                return(list(newY = newY, W = W[1:ncol(se.obj) , , drop = FALSE]))
            })
        all.ruv[[length(k.vals)]] <- newY.max
        if(is.null(output.name)){
            names(all.ruv) <- paste0('RUVIIIPRPS_K_', k.vals)
        } else names(all.ruv) <- paste0(output.name, k.vals)

    }
    ## k == 1 ####
    if(length(k) == 1) {
        ### check ncg ####
        ncg.set <- ncg
        ncg.logi <- rep(FALSE, nrow(se.obj))
        ncg.logi[ncg.set] <- TRUE
        ncg.set <- ncg.logi
        ## check prps data ####
        prps.data <- prps.data
        k.vals <- k
        ## merge Y and prps data ####
        Y <- t(cbind(Y, prps.data))
        if (is.data.frame(Y))
            Y <- data.matrix(Y)
        if (sum(is.na(Y)) > 0) {
            stop("The assay or PRPS data contains missing values. This is not supported.")
        } else if (sum(Y == Inf, na.rm = TRUE) + sum(Y == -Inf, na.rm = TRUE) > 0) {
            stop("The assay or PRPS data contains infinity values. This is not supported.")
        }
        ## apply RUV1 ####
        printColoredMessage(
            message = '- Apply RUV1 on the both assay and prps data:',
            color = 'blue',
            verbose = verbose
            )
        Y <- RUV1(
            Y = Y,
            eta = eta,
            ctl = ncg.set,
            include.intercept = include.intercept
        )
        ## data standardization ####
        printColoredMessage(
            message = '- Standardize the data:',
            color = 'blue',
            verbose = verbose
            )
        Y.stand <- scale(Y, center = TRUE, scale = FALSE)
        ## create M matrix ####
        printColoredMessage(
            message = '- Create M matrix:',
            color = 'blue',
            verbose = verbose
            )
        M <- replicate.matrix(row.names(Y))
        ## Sanity check on the M matrix ####
        printColoredMessage(
            message = '- Sanity check on the M matrix:',
            color = 'blue',
            verbose = verbose
            )
        sum(rowSums(M) != 1)
        sum(colSums(M) == 1)
        ## obtain residuals from the PRPS sets ####
        printColoredMessage(
            message = '- Obtain residuals from the PRPS sets:',
            color = 'blue',
            verbose = verbose
            )
        Y0 <- fastResidop2(Y, M)
        ## apply svd on the residuals and the obtain alpha ####
        printColoredMessage(
            message = '- Apply svd on the residuals to Obtain alpha:',
            color = 'blue',
            verbose = verbose
            )
        left.sing.value <- BiocSingular::runSVD(
            x = Y0,
            k = max(k.vals),
            BSPARAM = bsparam(),
            center = FALSE,
            scale = FALSE
        )$u
        alpha <- t(left.sing.value[, 1:k.vals, drop = FALSE]) %*% Y
        ac <- alpha[, ncg.set, drop = FALSE]
        ## obtain W ####
        printColoredMessage(
            message = '- calculate W :',
            color = 'blue',
            verbose = verbose
            )
        W <- Y.stand[, ncg.set] %*% t(ac) %*% solve(ac %*% t(ac))
        ## obtain normalized data ####
        printColoredMessage(
            message = '- obtain normalized data:',
            color = 'blue',
            verbose = verbose
        )
        newY <- Y - W %*% alpha
        newY <- t(newY[1:ncol(se.obj) ,])
        all.ruv <- list(newY = newY, W = W[1:ncol(se.obj) , , drop = FALSE])
        if(is.null(output.name))  output.name <- paste0('RUVIIIPRPS_K_', k.vals)
    }

    # Save data sets ####
    printColoredMessage(
        message = '-- Save all the RUV-III normalized data and W matrix:',
        color = 'magenta',
        verbose = verbose)

    ## saving the norm data into a new assay ####
    if (isTRUE(save.se.obj)) {
        printColoredMessage(
            message = '- Add all the RUV-III normalized as new assay to the SummarizedExperiment object:',
            color = 'blue',
            verbose = verbose)
        if(length(k) == 1){
            newY <- all.ruv$newY
            colnames(newY) <- colnames(se.obj)
            se.obj@assays@data[[output.name]] <- newY
        } else{
            for (x in 1:length(all.ruv)) {
                newY <- all.ruv[[x]]$newY
                colnames(newY) <- colnames(se.obj)
                se.obj@assays@data[[names(all.ruv[x])]] <- newY
            }
        }
        # saving the W and alpha as well ####
        if (isTRUE(return.info)) {
            # check if RUVIII already exists in the metadata
            if (length(se.obj@metadata) == 0) {
                se.obj@metadata[['RUVIII']] <- list()
            }
            # check if RUVIII already exists in the metadata
            if (!'RUVIII' %in% names(se.obj@metadata)) {
                se.obj@metadata[['RUVIII']] <- list()
            }
            ## check if W already exists in the RUVIII
            if (!'W' %in% names(se.obj@metadata[['RUVIII']])) {
                se.obj@metadata[['RUVIII']][['W']] <- list()
            }
            if(length(k) == 1){
                if (!output.name %in% names(se.obj@metadata[['RUVIII']][['W']])) {
                    se.obj@metadata[['RUVIII']][['W']][[output.name]] <- list()
                }
                se.obj@metadata[['RUVIII']][['W']][[output.name]] <- all.ruv$W
            } else if (length(k) > 1){
                for(x in 1:length(all.ruv)){
                    output.name <- names(all.ruv[x])
                    ## Check if metadata RUVIII already exist for this assay
                    if (!output.name %in% names(se.obj@metadata[['RUVIII']][['W']])) {
                        se.obj@metadata[['RUVIII']][['W']][[output.name]] <- list()
                    }
                    se.obj@metadata[['RUVIII']][['W']][[output.name]] <- all.ruv[[x]]$W
                }
            }
        }
        printColoredMessage(message = '------------The RUVIII.PRPS function finished.',
                            color = 'white',
                            verbose = verbose)
        return(se.obj)
    } else if (!return.info & !save.se.obj) {
        printColoredMessage(message = '------------The RUVIII.PRPS function finished.',
                            color = 'white',
                            verbose = verbose)
        return(all.ruv)
    } else if (return.info & !save.se.obj) {
        printColoredMessage(message = '------------The RUVIII.PRPS function finished.',
                            color = 'white',
                            verbose = verbose)
        return(all.ruv)
    }
}
